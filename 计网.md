## TCP⭐

### 特点

**TCP 是面向连接的**，一个应用进程在向另一个进程发送数据前必须先建立连接，发送某些预备报文段。

**TCP 提供全双工服务**，允许通信双方的应用进程在任何时候发送数据。TCP 连接的两端都有发送缓存和接收缓存：发送时，应用程序把数据传送给 TCP 缓存后就可以做自己的事，TCP 在合适的时候发送；接收时，TCP 把收到的数据放入缓存，应用程序在合适的时候读取。

**TCP 连接是点对点的**，只能是单个发送方和单个接收方之间的连接。

**TCP 提供可靠的交付服务**，通过 TCP 传送的数据无差错、不丢失、不重复，按序到达。

**TCP 是面向字节流的**，流是指流入进程或从进程流出的字节序列。虽然应用程序和 TCP 的交互是每次一个数据块，但 TCP 把数据块仅看成一连串无结构的字节流。TCP 不保证接收方的数据块和发送方的数据块具有对应大小的关系，但接收方的字节流必须和发送方的字节流完全一样。应用程序必须有能力识别收到的字节流，把它还原成应用层数据。

---

### UDP 和 TCP 的区别⭐

UDP 无连接，发送数据前不需要建立连接，减少了开销和时延。

UDP 使用尽最大努力交付，不保证可靠性，主机不需要维持复杂的连接状态。

UDP 面向报文，UDP 对应用层报文添加首部后就交付 IP 层。

UDP 没有拥塞控制，网络拥塞不会降低源主机的发送速率，这对某些实时应用很重要，如视频会议。

UDP 支持一对一、一对多和多对多通信。

----

### TCP 报文结构

TCP 报文段分为首部和数据两部分。首部的前 20 个字节固定，后面有 4n 字节根据需要增加。

| 字段             | 大小 | 说明                                                         |
| ---------------- | ---- | ------------------------------------------------------------ |
| 源端口和目的端口 | 2B   | 分别写入源端口号和目的端口号，TCP 的分用功能是通过端口实现的。 |
| 序号             | 4B   | 本报文段所发数据第一个字节的序号，使用 mod 2^32^ 计算。      |
| 确认号           | 4B   | 期望收到对方下一个报文段第一个字节的序号，确认号为 N 代表到 N-1 为止都已收到。 |
| 数据偏移         | 4B   | 指出了报文的数据起始处到报文起始处的距离。                   |
| 标志             | 6b   | URG：紧急，URG=1 时表示存在紧急数据，不再排队等待发送，需要和紧急指针配合使用。 |
|                  |      | ACK：确认，ACK=1 时表示成功接收了报文段。                    |
|                  |      | SYN：同步，在建立连接时用来同步序号，SYN=1 表示一个连接请求或连接响应报文。 |
|                  |      | FIN：终止，用来释放连接，当 FIN=1 时表示发送方已发送完毕，并要求释放连接。 |
|                  |      | PSH：推送，PSH=1 时接收方不再等待整个缓存填满再交付数据，而是尽快交付数据。 |
|                  |      | RST：复位，当 RST=1 时表示 TCP 连接出现了严重错误，必须释放再重新建立连接。 |
| 接收窗口         | 2B   | 限制发送方的发送窗口，因为接收方的缓存有限。                 |
| 检验和           | 2B   | 检验包括首部和数据两部分，如果接收方检测到差错会丢弃 TCP 报文。 |

----

### 自动重传请求 ARQ

ARQ 包括停止等待协议、回退 N 步协议和选择重传协议，后两种结合了窗口机制，属于连续 ARQ 协议。

**停止等待协议**

每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。包括三种情况：

- **无差错**

  A 发送分组 M~1~，发送完后暂停并等待 B 的确认；B 收到 M~1~ 后向 A 发送确认；A 收到确认后再发送下一个分组 M~2~。

- **出现差错**

  B 收到 M~1~ 后检测到了差错，或者 M~1~ 在传输过程中丢失，这两种情况下 B 都不会发送确认信息，解决方法是：A 只要超过一段时间没有收到确认，就进行超时重传，每发送完一个分组就设置**超时计时器**，如果在计时器到期前收到确认就撤销计时。

  注意：① 发送完分组后必须暂时保留副本，收到确认再清除。② 分组和确认分组都必须进行编号。③ 超时时间应当比分组传输的往返时间稍长，过短会产生不必要的重传，过长会降低通信效率。

- **确认丢失和确认迟到** 

  B 发送的确认丢失，A 会超时重传，B 会丢弃重传分组并重新确认；B 发送的确认迟到，A 收到重复确认后将其丢弃。

  通常 A 最终总是可以收到对所有发出分组的确认，如果 A 不断重传分组但总收不到确认，就说明通信线路质量太差，不能通信。

停止等待协议的优点是简单，缺点是信道利用率低。为了提高传输效率，发送方可以连续发送多个分组，不必每发送完一个分组就停下来等待确认，使信道上一直有数据传送。但流水线传输可能会遇到差错，解决方法包括回退 N 步和选择重传。

----

**回退 N 步协议**

回退 N 步即 GBN 协议，允许发送方发送多个分组而不需要等待确认。GBN 中发送方已发送但还未确认的序号和允许发送但还未发送的序号可以被看作一个长度为 N 的窗口，随协议运行该窗口向前滑动，因此 GBN 也被称为滑动窗口协议。

GBN 采用**累积确认**的方式，对按序到达的最后一个分组发送确认，如果超时，发送方会重传所有已发送但还未确认的分组。例如发送了序号为 1~5 的五个分组，除了第三个全部收到了，那么确认序号就是 2，发送方将重传 3~5 的分组。

在 GBN 中，接收方丢弃所有失序分组，因为接收方必须按序交付数据。这种做法的优点是缓存简单，不需要缓存任何失序分组；缺点是对失序分组的重传可能出错而导致更多重传。

---

**选择重传协议**

GBN 中单个分组的差错就能引起大量分组重传，随着信道差错率的增加，流水线会被不必要重传的分组所充斥。

选择重传即 SR 协议，让发送方仅重传那些它怀疑接收出错的分组，避免不必要的重传。接收方将确认一个正确接收的分组而不管其是否按序，失序分组将被缓存直到收到所有丢失分组，此时将分组按序交付上层。

---

### TCP 可靠原理

TCP 的可靠传输包含很多机制，例如使用**检验和**来检测传输中的比特错误、使用**定时器**超时重传、使用**序号**检测丢失分组和冗余副本、使用**确认号**告诉发送方确认的分组信息。

TCP 的发送方仅需维持已发送但未确认的最小序号，以及下一个要发送的序号，从这种角度看 TCP 像一个 GBN 协议。但 TCP 和 GBN 的区别是 TCP 会将正确接收但失序的报文缓存起来，当分组 n 丢失时，GBN 会重传 n 之后的所有分组，但 TCP 至多只会重传分组 n。TCP 允许接收方有选择地确认失序报文段，而不是累积确认最后一个正确接收的有序报文段，从这个角度看 TCP 又像 SR 协议。因此 TCP 的差错恢复机制是一种 GBN 和 SR 的结合体。

---

### 滑动窗口

滑动窗口以字节为单位。发送端有一个发送窗口，窗口中的序号是允许发送的序号，窗口的后沿是已发送且确认的序号，窗口的前沿是不允许发送的序号。窗口的后沿可能不动（没有收到新的确认），也有可能前移（收到了新的确认），但不会后移（不可能撤销已经确认的数据）。窗口的前沿一般是向前的，可能不动（没有收到新的请求或对方的接收窗口变小），也可能收缩（TCP 强烈不建议这么做，因为发送端在收到通知前可能已经发送了很多数据，将产生错误）。

发送缓存存放应用程序传给 TCP 准备发送的数据和已发送但还未确认的数据；接收缓存存放按序到达但尚未被应用程序读取的数据和未按序到达的数据。

发送窗口根据接收窗口设置，但并不总是一样大，还要根据网络的拥塞情况调整。

接收方必须有累积确认功能，既可以在合适的时候确认，也可以在发送数据时捎带确认，但不能过分推迟，一般不超过 0.5 秒。

---

### 流量控制

如果应用程序读取的速度较慢，而发送方发送得太快，就会使接收缓存溢出，TCP 通过流量控制解决该问题。

TCP 通过接收窗口实现流量控制，接收窗口告诉发送方自己可用的缓存空间，发送方的发送窗口不能超过接收方的接收窗口。

当接收窗口=0 时就不再允许发送方发送数据，但可能存在一种情况：在发送零窗口报文不久后，接收方的接收缓存又有了存储空间，因此发送报文说明新的接收窗口，但该报文在传输中丢失。发送方会一直等待接收方的非零窗口通知，而接收方也一直在等待发送方发送数据，形成死锁。为解决该问题，TCP 为每个连接设有**持续计时器**，只要 TCP 连接的一方收到对方的零窗口通知，就启动该计时器，到期后发送一个**零窗口探测报文**，避免死锁。

有一种问题叫**糊涂窗口综合症**，当接收方处理数据很慢时，应用进程间传送的有效数据很小， 极端情况下有效数据只有 1B 但传输开销却有 40B（IP 首部及TCP 首部各占 20B) ，导致通信效率极低。为解决该问题，可以等到接收方有足够空间容纳一个最长报文段，或接收缓存已有一半空间再发送；发送方也不要发送太小的报文，而是把数据积累成足够大的报文，或达到接收方缓存一半时才发送。

---

### 拥塞控制

网络中对资源的需求超过可用量的情况就叫拥塞，当吞吐量明显小于理想吞吐量时就出现了轻度拥塞。拥塞控制就是减少注入网络的数据，减轻路由器和链路的负担，这是一个全局性问题，涉及网络中的所有路由器和主机，而流量控制是一个端到端的问题。

根据网络层是否为拥塞控制提供显式帮助，将拥塞控制分为：**端到端拥塞控制**和**网络辅助的拥塞控制**。TCP 使用端到端的拥塞控制，因为 IP 层不会向端系统提供显式的拥塞反馈。TCP 让发送方根据拥塞程度限制发送速率。如果发送方感知到没什么拥塞会增加发送速率，否则会降低发送速率。限制发送速率通过拥塞窗口实现，判断拥塞通过超时或连续接收到 3 个冗余 ACK 实现。

TCP 的拥塞控制算法包括了慢启动、拥塞避免和快恢复。慢启动和拥塞避免是 TCP 的强制部分，差异在于对收到的 ACK 做出反应时拥塞窗口增加的方式，慢启动比拥塞避免增加得更快。快恢复是推荐部分，对 TCP 发送方不是必须的。

**1. 慢启动**

拥塞窗口 cwnd 以一个 MSS 最大报文段开始，每当传输的报文段首次被确认就增加一个 MSS。因此每经过一个 RTT 往返时间，拥塞窗口就会翻倍，发送速率也会翻倍。

结束慢启动的情况：① 发生超时事件，发送方将 cwnd 设为 1，重新开始慢启动，并将慢启动阈值设置为 cwnd/2。② 当拥塞窗口达到慢启动阈值时就结束慢启动而进入拥塞避免模式。③ 如果检测到三个冗余的 ACK，TCP 就会执行快重传并进入快恢复状态。

**2. 拥塞避免**

一旦进入拥塞避免状态，cwnd 值大约是上次拥塞时的 1/2，距离拥塞并不遥远。因此 TCP 不会每经过一个 RTT 就将 cwnd 翻倍，而是较为保守地在每个 RTT 后将 cwnd 加 1。

发生超时事件时，拥塞避免和慢启动一样，将 cwnd 设为 1，并将慢启动阈值设置为 cwnd/2。

**3. 快恢复**

有时个别报文段丢失，但网络中并没有出现拥塞，如果使用慢启动会降低传输效率。这时应该使用快重传来让发送方尽早知道出现了个别分组的丢失，快重传要求接收端不要等待自己发送数据时再捎带确认，而是要立即发送确认。即使收到了乱序的报文段也要立即发出对已收到报文段的重复确认。当发送方连续收到三个冗余 ACK 后就知道出现了报文段丢失的情况，会立即重传并进入快恢复状态。

在快恢复中，会调整慢启动阈值为 cwnd/2，并进入拥塞避免状态。

---

### 三次握手⭐

TCP 是全双工通信，任何一方都可以发起连接请求，假设 A 是客户端，B 是服务器。

初始 A 和 B 均处于 CLOSED 状态，B 会创建传输进程控制块 TCB 并进入 LISTEND 状态，监听端口是否收到连接请求。

当 A 要发送数据时，就向 B 发送连接请求报文，其中 SYN=1，ACK=0，SYN 不可以携带数据，但要消耗一个序号（假设 seq=x）。发送后 A 进入 SYN-SENT 同步已发送状态。

当 B 收到 A 的连接请求报文后，进入 SYN-RCVD 同步已接收状态，如果同意建立连接就会发送给 A 一个连接响应报文，其中 SYN=1，ACK=1，ack=x+1，seq=y。ack 的值为 A 发送的序号加 1，ACK 可以携带数据，如果不携带的话则不消耗序号。

当 A 收到 B 的确认后，还要对该确认再进行一次确认，报文的 ACK=1，ack=y+1，seq=x+1，发送后 A 进入 ESTABLISHED 状态，当 B 接收到该报文后也进入 ESTABLISHED 状态，客户端会稍早于服务器端建立连接。

三次握手的原因：

- 从信息对等的角度看，双方只有确定 4 类信息才能建立连接，即 A 和 B 分别确认自己和对方的发送和接收能力正常。在第二次握手后，B 还不能确定自己的发送能力和 A 的接收能力，只有在第三次握手后才能确认。

- 报文的生存时间往往会超过 TCP 请求的超时时间，A 的某个超时连接请求可能会在双方释放连接后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。由于 A 的状态不是 SYN_SENT，将直接丢弃 B 的确认数据。如果是两次握手，连接建立，服务器资源被白白浪费；如果是三次握手，B 由于长时间没有收到确认，最终超时导致连接失败，不会出现脏连接。

---

### 四次挥手⭐

当 A 没有要发送的数据时就会向 B 发送终止连接报文，其中 FIN=1，seq=u，u 的值为之前 A 发送的最后一个序号加 1，发送后 A 进入 FIN-WAIT-1 状态。

B 收到后响应给 A 一个确认报文，ACK=1，ack=u+1，seq=v，v 的值为 B 之前发送的最后一个序号加 1。此时 A 进入 FIN-WAIT-2 状态，B 进入 CLOSE-WAIT 状态，但连接并未完全释放，B 会通知应用进程结束 A 到 B 方向的连接，此时 TCP 处于半关闭状态。

当 B 也准备释放连接时就向 A 发送连接终止报文，FIN=1，同时还要重发 ACK=1，ack=u+1，seq=w，seq 改变的原因是在半关闭状态 B 可能又发送了数据，之后 B 进入 LAST-ACK 状态。

A 收到连接终止报文后还要再进行一次确认，确认报文中 ACK=1，ack=w+1，seq=u+1，发送完后进入 TIME-WAIT 状态，等待 2MSL 后进入 CLOSED 状态。B 收到该确认后进入 CLOSED 状态，服务器端会稍早于客户端释放连接。

四次挥手的原因：TCP 是全双工通信，两个方向的连接需要单独断开。

等待 2MSL 的原因：

- 保证被动关闭方可以进入 CLOSED 状态。MSL 是最大报文段寿命，等待 2MSL 可以保证 A 发送的最后一个确认报文被 B 接收，如果该报文丢失，B 会超时重传之前的 FIN+ACK 报文，而如果 A 在发送确认报文后立即释放连接就无法收到 B 可能超时重传的报文，也不会再次发送确认报文段，B 就无法正常进入 CLOSED 状态。

- 2MSL 时间后，本连接中的所有报文就都会从网络中消失，防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。

除此之外，TCP 还设有一个**保活计时器**，用于解决客户端故障问题，服务器每收到一次数据就重新设置保活计时器，如果 2 小时内没有收到数据就间隔 75 秒发送一次探测报文，连续 10 次没有响应后关闭连接。

**TIME-WAIT**

在高并发短连接的 TCP 服务器上，服务器处理完请求后立刻主动关闭连接，该场景下大量 socket 处于 TIME-WAIT 状态。TIME-WAIT 状态无法真正释放句柄资源，socket 使用的本地端口在默认情况下不能再被使用，会限制有效连接数量，成为性能瓶颈。

解决：调小 `tcp_fin_timeout` 的值、将 `tcp_tw_reuse` 设为 1 开启重用，将 `tcp_tw_recycle` 设为 1 开启快速回收。

----

## HTTP 

### 概况

HTTP 超文本传输协议，由客户程序和服务器程序实现，客户程序和服务器程序通过交换 HTTP 报文进行会话。HTTP 定义了这些报文的结构以及报文交换的方式，当用户请求一个 Web 页面时，浏览器向服务器发出对该页面中所包含对象的 HTTP 请求报文，服务器接收请求并返回包含这些对象的 HTTP 响应报文。

HTTP 使用 TCP 作为运输协议，它基于 TCP/IP 来传输文本、图片、视频、音频等，HTTP 并不提供数据包的传输功能，而仅仅是**客户端和服务端约定好的一种通信格式**。HTTP 客户首先发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字访问 TCP。客户向它的套接字接口发送请求报文，服务器从它的套接字接口接收请求报文。

HTTP 是一种无状态的协议，服务器不存储任何关于该客户的状态信息。假如某个客户在短时间内连续两次请求同一个对象，服务器并不会因为刚刚为该客户做出了响应就不再响应，而是重新进行响应。

---

### URI / URL

我们可以通过输入 `www.google.com` 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 `URI` 的规范。

`URI`的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。

`URL`的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的`网址`，它实际上是 URI 的一个子集。

URL是URI的一种，还有一种是 URN（统一资源名称），通过资源名称就能定位到资源。它们之间的关系如下：

<center><img src="assets/image-20220909161647695.png" ></center>

----

### 非持续连接和持续连接

非持续连接必须为每个请求维护一个连接，对于每个连接，在客户和服务器中都要分配 TCP 缓冲区，给服务器造成很大负担。每次请求到响应大约需要花费两个 RTT 加上服务器传输文件的时间，RTT 指分组从客户到服务器再返回客户的时间。三次握手的前两部分占用一个 RTT，第三部分向服务器发送请求报文，服务器收到后做出响应，占用另一个 RTT。

HTTP1.1 使用持续连接，服务器响应后保持连接打开。在相同客户与服务器之间，后续的请求和响应 报文能够通过相同的连接进行传送。

---

### 报文格式

#### 请求报文

请求报文包括**请求行、首部行和实体**：

<center><img src="assets/image-20220909162258744.png" ></center>

- 请求行包括方法、URL 和 HTTP 版本。方法包括了 GET、POST、HEAD、PUT 和 DELETE 等。HEAD 类似于 GET，当服务器收到一个 HEAD 请求时，会用一个 HTTP 报文进行响应，但并不返回请求对象，通常使用 HEAD 进行调试；PUT 常用于上传对象到 Web 服务器；DELETE 用于删除 Web 服务器上的对象。 

- 首部行可以携带信息，例如 `Connection:close` 可以告诉服务器不要使用持续连接；`User-agent` 可以指明浏览器类型，服务器可以为不同类型的用户代理发送对象的不同版本。 

- 在首部行后有一个空行，后面跟着的是实体。使用 GET 时实体为空，而使用 POST 时才会使用实体。

HTTP 请求方法一般分为 8 种，它们分别是

- `GET 获取资源`，GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；

- `POST 传输实体`，虽然 GET 方法也可以传输主体信息，但是便于区分，我们一般不用 GET 传输实体信息，反而使用 POST 传输实体信息，

- PUT 传输文件，PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

  但是，鉴于 HTTP 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 W eb 网站不使用该方法。若配合 W eb 应用程序的验证机制，或架构设计采用`REST（REpresentational State Transfer，表征状态转移）`标准的同类 Web 网站，就可能会开放使用 PUT 方法。

- HEAD 获得响应首部，HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。

- DELETE 删除文件，DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。

- OPTIONS 询问支持的方法，OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

- TRACE 追踪路径，TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。

- CONNECT 要求用隧道协议连接代理，CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 `SSL（Secure Sockets Layer，安全套接层）`和 TLS`（Transport Layer Security，传输层安全）`协议把通信内容加 密后经网络隧道传输。



#### 响应报文

响应报文包括状态行、首部行和实体：

<center><img src="assets/image-20220909162315401.png" ></center>

- 状态行包括协议版本、状态码和对应的状态信息。

- 首部行中，`Date` 是服务器发送响应报文的时间；`Server` 指明了服务器类型，类似于请求报文中的 `User-agent` 。
- 实体是报文的主要部分，即所请求的对象本身。



| 状态码 | 短语                       | 含义                                                         |
| ------ | -------------------------- | ------------------------------------------------------------ |
| 200    | OK                         | 成功响应                                                     |
| 301    | Moved Permanently          | 请求对象已被永久转移，新的 URL 定义在响应报文的首部行，客户端将自动获取。 |
| 302    | Found                      | 与301类似，但资源只是临时被移动，客户端继续使用原有 URL。    |
| 304    | Not Modified               | 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 |
| 400    | Bad Request                | 通用的差错代码，请求不能被服务器理解。                       |
| 401    | Unauthorized               | 未认证，缺乏相关权限。                                       |
| 402    | Payment Required           | 保留，将来使用。                                             |
| 403    | Forbidden                  | 服务器理解客户端的请求，但是拒绝执行。                       |
| 404    | Not Found                  | 被请求的文档不在服务器上，有可能因为请求 URL 出错。          |
| 405    | Method Not Allowed         | 客户端中请求的方法被禁止，例如限制 POST 方式但使用了 GET 访问。 |
| 500    | Internal Server Error      | 服务器内部错误，无法完成请求。                               |
| 501    | Not Implemented            | 服务器不支持请求的功能，无法完成请求。                       |
| 502    | Bad Gateway                | 作为网关或代理工作的服务器尝试执行请求时，从远程服务器收到了一个无效响应。 |
| 503    | Service Unavailable        | 由于超载或系统维护，服务器暂时无法处理客户端的请求。         |
| 504    | Gateway Timeout            | 充当网关或代理的服务器，未及时从远端服务器获取请求。         |
| 505    | HTTP Version Not Supported | 服务器不支持请求报文使用的 HTTP 版本。                       |

- 以`1xx` 为开头属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少；
- 以 `2xx` 为开头的都表示请求成功响应；
- 以 `3xx` 为开头的都表示需要进行附加操作以完成请求，比如重定向；
- 以 `4xx` 的响应结果表明客户端是发生错误的原因所在，比如有错误的语法或不能完成；
- 以 `5xx` 为开头的响应标头都表示服务器本身发生错误；



----

### 首部行

首部行分为通用首部、请求首部、响应首部、实体首部。其中请求首部只在请求报文，响应首部只在响应报文。通用首部和实体首部请求和响应都可以。

**通用首部：**

- **Cache-Control**：通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。
- **Connection**：控制不再转发给代理的首部字段（在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段），管理持久连接keep-alive（1.1以后默认持久连接，当服务器端想明确断开连接时，则指定Connection首部字段的值为Close）。
- **Date**：首部字段Date表明创建HTTP报文的日期和时间。
- Pragma：Pragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。 但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。
- Trailer：首部字段Trailer会事先说明在报文主体后记录了哪些首部字段
- **Transfer-Encoding**：首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。
- Upgrade：首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。
- Via：使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径
- Warning：该首部通常会告知用户一些与缓存相关的问题的警告

**请求首部：**

- **Accept**：通知服务器，用户代理能够处理的媒体类型(比如html)及媒体类型的相对优先级(范围0-1)，当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。
- **Accept-Charset:**可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序
- **Accept-Encoding**：Accept-Encoding首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序
- **Accept-Language**：用来告知服务器用户代理能够处理的自然语言集用来告知服务器用户代理能够处理的自然语言集
- **Authorization**：用来告知服务器，用户代理的认证信息（证书值）
- Expect：告知服务器，期望出现的某种特定行为。HTTP/1.1规范只定义了100-continue，等待状态码100响应的客户端在发生请求时，需要指定Expect:100-continue。
- From：首部字段From用来告知服务器使用用户代理的用户的电子邮件地址
- **Host**：请求的资源所处的互联网主机名和端口号。首部字段Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段Host必须存在的意义，有了 Host 字段，就可以将请求发往同一台服务器上的不同网站。
- If-Match：形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求
- If-Modified-Since：它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求。而在指
- If-Modified-Since字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码304Not Modified的响应。
- If-None-Match：它和首部字段If-Match作用相反。用于指定If-None-Match字段值的实体标记（ETag）值与请求资源的ETag不一致时，它就告知服务器处理该请求。
- If-Range：它告知服务器若指定的If-Range字段值（ETag值或者时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。
- Referer：首部字段Referer会告知服务器请求的原始资源的URI。
- Range：对于只需获取部分资源的范围请求，包含首部字段Range即可告知服务器资源的指定范围
- Cookie：客户端请求服务器使用的Cookie

**响应首部：**

- Accept-Ranges：首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为bytes，反之则指定其为none。
- Age：首部字段Age能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。代理创建响应时必须加上首部字段Age
- ETag：首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值
- Location：使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源。基本上，该字段会配合3xx:Redirection的响应，提供重定向的URI。
- Proxy-Authenticate：首部字段Proxy-Authenticate会把由代理服务器所要求的认证信息发送给客户端
- Set-Cookie：设置cookie

**实体首部：**

- Allow：首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。
- **Content-Encoding**：告知客户端服务器对实体的主体部分选用的内容编码方式
- **Content-Language**：实体主体使用的自然语言
- **Content-Length**：表明了实体主体部分的大小
- **Content-Location**：给出与报文主体部分相对应的URI
- Content-MD5：一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。
- Content-Range：针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求
- **Content-Type**：实体主体内对象的媒体类型，比如text/html; charset=utf-8
- Expires：首部字段Expires会将资源失效的日期告知客户端。
- Last-Modified：首部字段Last-Modified指明资源最终修改的时间。



### 缓存

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

所以，避免发送 HTTP 请求的方法就是通过**缓存技术**，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

#### Cache-Control

请求首部Cache-Control的值：

1. no-cache。当客户端请求时携带这个首部字段的时候，通过中间的缓存服务器时，会不去拿缓存资源，而是让中间服务器转发给资源服务器，资源服务器看看一下这个资源过期没有，如果没有就会告知中间服务器，可以使用缓存资源。否则资源服务器就会直接返回新的资源；

2. no-store。这个字段非常有意思，就是告知服务器或者客户端以及中间服务器，我请求或者响应的内容里面有机密信息，这些响应的内容是永远不会得到响应的；
3. max-age。`max-age`指令标示了客户端不愿意接收一个`age`大于设定时间的响应，这个字段表达是最大缓存时长，请求中单单添加这个字段，实现不了缓存时长，必须结合响应的max-age。一会，会在响应中的max-age 详细说明；

4. max-stale。这个指令表达的是缓存时长过期以后，还可以有效。比如现在max-age：60秒，那么max-stale：60秒，现在的缓存时长就是120秒；
5. min-fresh。设定能够容忍的最小**新鲜度（缓存时长）**。`min-fresh`标示了客户端不愿意接受**新鲜度**不多于当前的`age`加上`min-fresh`设定的时间之和的响应；
6. no-transfrom。使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型；
7. only-if-cache。使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下，才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout；
8. cache-extension。通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字 段内的指令。



响应首部Cache-Control的值：

1. pulic。这个字段和private是相对的，Cache-Control: public时，则表明所有的用户在通过缓存服务器的时候，都可以缓存这个资源；

2. private。这个字段和pulic是相对的，Cache-Control: private时，则表明只有某个在通过缓存服务器的时候，得到缓存资源；

3. no-cache。如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作；

4. no-store。同请求首部的no-store指令一样；

5. no-transfrom。同请求首部的no-transfrom指令一样；

6. max-age。在Response中设置max-age的时间信息，可以在客户端生成缓存文件，在缓存不过期的情况下，客户端不会直接向服务器请求数据，在缓存过期的情况下，客户端会向服务器直接请求生成新的缓存。

   如果同时设置了Response和Request中的max-age 缓存时间，如果Request中的max-age时间小于Response中的max-age时间，客户端会根据Request中max-age时间周期去直接进行网络请求，如果碰到断网或者网络请求不通的情况，即使缓存还在有效期内（Response中设置的max-age时间足够大），在Request设置的max-age过期之后，APP也会直接去进行网络请求。  因此可以考虑在客户端的设计中一个和好的网络缓存场景，用Response的max-age控制缓存的时间，用Request中max-age控制刷新的时间和机制

   **应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略**

7. s-max-age。和max-age类似，它们的不同点是 s- maxage 指令只适用于供多位用户使用的公共缓存服务器 ；
8. must-revalidate。使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）；
9. proxy-revalidate。proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性；
10. cache-extension。同请求首部的cache-extension指令一样



#### 强制缓存

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。

<center><img src="assets/1cb6bc37597e4af8adfef412bfc57a42.png"  width="80%"></center>

强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：

- `Cache-Control`， 是一个相对时间；
- `Expires`，是一个绝对时间；

如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control的优先级高于 Expires** 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。



#### 协商缓存

当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。	

<center><img src="assets/缓存etag.png" width="80%"></center>

上图就是一个协商缓存的过程，所以**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现。

第一种：请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：

- 响应头部中的 `Last-Modified`：表示这个响应资源的最后修改时间；
- 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

第二种：请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：

- 响应头部中 `Etag`：唯一标识响应资源，是第一次请求的响应头部中的摘要；
- 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

> **第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的**，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，**这时 Etag 的优先级更高**，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。

**为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：

1. 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；
2. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
3. 有些服务器不能精确获取文件的最后修改时间。



#### 强制缓存+协商缓存

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

下图是强制缓存和协商缓存的工作流程：

<center><img src="assets/http缓存.png" width="80%"></center>

当使用 ETag 字段实现的协商缓存的过程：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；

- 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：

  - 如果没有过期，则直接使用本地缓存；
  - 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；

- 服务器再次收到请求后，

  会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：

  - **如果值相等，则返回 304 Not Modified，不会返回资源**；
  - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；

- 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。







### GET 和 POST 的区别

- GET 是幂等的，可以多次执行没有副作用，读取一个资源，可以将 GET 数据缓存在浏览器、代理或服务端。（反复 GET 不应该对访问有副作用，没有副作用被称为幂等。 ）

  POST 不是幂等的，意味着不能随意多次执行，因此不能缓存，如果尝试重新执行 POST 请求，浏览器会弹出提示框询问是否重新提交表单。 

- GET 请求由 url 触发，想携带参数就只能在 url 后附加。 

  POST 请求来自表单提交，表单数据被浏览器编码到 HTTP 请求报文的请求体中。主要有两种编码格式，一种是 `application/..`，用来传输简单数据；另一种是 `multipart/form-data`格式，用来传输文件，对二进制数据传输效率高。

- 从攻击的角度说，无论 GET 还是 POST 都不安全，因为 HTTP 是明文协议，只要抓个包就都能看到了；

- GET 长度受限于 url，而 url 的长度由浏览器和服务器决定。

  POST 没有大小限制，起限制作用的是服务器的处理能力。

---

### cookie

HTTP 的无状态性简化了服务器设计，提高了性能，使其可以同时处理大量 TCP 连接。但无状态也导致服务器不能识别用户，为解决该问题 HTTP 使用 cookie 客户端会话技术对用户进行追踪。

**工作流程**

① 当客户通过浏览器第一次访问站点时，该站点将产生一个唯一识别码，并以此作为索引，在后端数据库中产生一个表项。

② 服务器用一个包含 `Set-cookie` 首部的 HTTP 响应报文对浏览器进行响应，浏览器收到后将其添加到自己管理的 cookie 文件。

③ 在下次访问该站点时，请求报文的首部行会包括这个识别码，尽管浏览器不知道客户是谁，但可以确定是同一个客户。

**cookie 和 session 的区别**

① cookie 只能存储 ASCII 码，而 session 可以存储任何类型的数据。

② session 存储在服务器，而 cookie 存储在客户浏览器中，容易被恶意查看。

③ session 的运行依赖 session id，而 session id 存在 cookie 中，叫做 JSESSIONID。如果浏览器禁用了 cookie ，同时 session 也会失效（可以通过其它方式实现，比如在 url 中传递 session_id）。

----

### 输入一个 url 发生的事

判断 url 是否合法，如果不合法会使用默认的搜索引擎进行搜索。如果输入的是一个域名，默认会加上一个 http 前缀。

先检查浏览器的 DNS 缓存，没有则检查本地 hosts 文件的缓存，如果仍然没有会向本地 DNS 服务器发送请求，最终本地 DNS 服务器得到域名和 IP 地址的映射关系，把结果返回给用户并进行缓存。

获取 IP 地址后，通过 TCP 三次握手建立连接，发送请求报文。

服务器收到请求报文后进行响应，主进程进行监听，创建子进程处理，先判断是否是重定向，如果是重定向则返回重定向地址。如果是静态资源则直接返回，否则通过 REST URL 在代码层面处理，最后返回响应报文。

浏览器收到 HTTP 响应报文后进行解析，首先查看响应报文的状态码，根据不同的状态码做不同处理。之后解析 HTML、CSS、JS 等文件，构建 DOM 树，构建CSS树，构建渲染树，布局渲染树，页面渲染。

通过 TCP 的四次挥手断开连接，如果是 HTTP1.1 则会将连接保持一小段时间。

---

### HTTP版本

#### HTTP 0.9

HTTP问世之初并没有作为标准建立，被正式制定为标准是在1996年公布的HTTP/1.0协议。因此，在这之前的协议被称为HTTP/0.9。

- **只支持`GET`请求方式**：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息；

- **没有请求头概念**：所以不能在请求中指定版本号，服务端返回仅包含文件内容本身：

  ```html
  <html>
    <body>HELLO WORLD!</body>
  </html>
  ```

- 服务端相响应之后，立即关闭TCP连接。



#### HTTP 1.0

随着互联网技术的飞速发展，HTTP协议被使用的越来越广泛，协议本身的局限性已经不能满足互联网功能的多样性。因此，`1996年5月HTTP/1.0诞生`，其内容和功能都大大增加了。对比与HTTP/0.9，新的版本包含了以下功能：

- 请求方式新增了POST，DELETE，PUT，HEADER等方式；
- 增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码content-encoding)；
- 扩充了传输内容格式，在header中添加content-type以此可以传输html之外类型的文件，图片、音视频资源、二进制等都可以进行传输。

在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。

```html
GET /index.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)

200 OK
Date: Tue, 15 Nov 1994 08:12:31 GMT
Server: CERN/3.0 libwww/2.17
Content-Type: text/html；charset=utf-8 // 类型，编码。
<HTML>
A page with an image
  <IMG src="/image.gif">
<HTML>
```



#### HTTP 1.1

仅仅在HTTP/1.0公布后的几个月，HTTP/1.1发布了，到目前为止`HTTP1.1协议都是作为主流的版本`，以至于随后的近10年时间里都没有新的HTTP协议版本发布。

对比之前的版本，其主要更新如下：

- **引入了持续连接**（keep-alive），**在之前，非持续连接每获取一次资源都需要进行DNS解析过程以及TCP的三次握手，但在同服务器获取资源不断的建立和断开链接需要消耗的资源和时间是巨大的，为了提升连接的效率，持久连接使得服务器响应后保持连接打开，在相同客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送**；

- **添加了Pipeline**，客户端可以以流水线的方式发送请求，也就是允许在第一个请求的答案完全传输之前发送第二个请求这降低了通信的延迟，但pipeline要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达，造成http的**队头阻塞**；

- **chunked机制，分块响应**。用户通常会通过response header中返回的`Content-Length`来判断服务端返回数据的大小。但随着网络技术的不断发展，越来越多的动态资源被引入进来，这时候服务端就无法在传输之前知道待传递资源的大小，也就无法通过Content-Length来告知用户资源大小。**服务器可以一边动态产生资源，一边传递给用户**，这种机制称为“分块传输编码”（Chunkded Transfer Encoding），**允许服务端发送给客户端的数据分为多个部分**，此时服务器端需要在header中添加“**Transfer-Encoding: chunked**”头域来替代传统的“Content-Length。

  ```html
  Transfer-Encoding: chunked
  ```

  通过分块响应可以实现**断点传输**，在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率。

- 引入了cache机制，当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段**cache-control**来控制缓存；

- 引入了内容协商，包括语言、编码和类型，客户端和服务器现在可以就交换哪些内容达成一致；

- **请求首部新增Host首部行**。在 `HTTP1.0` 中认为每台服务器都绑定一个唯一的 `IP` 地址，因此，请求消息中的 `URL` 并没有传递主机名（`hostname`）,1.1中新增的host用来处理一个 `IP` 地址上面多个虚拟主机的情况。在请求头域中新增了Host字段，其**用来指定同一个ip服务器的不同域名**。有了Host字段，在同一台服务器上就可以搭建不同的网站了，这也为后来虚拟化的发展建好啦地基。

  ```bash
  Host: www.alibaba-inc.com
  ```

  

#### HTTP 2.0

根据时代的发展网页变得更加复杂。其中一些甚至本身就是应用程序。显示了更多的视觉媒体，增加了交互性的脚本的数量和大小也增加了。更多的数据通过更多的 HTTP 请求传输，这为 HTTP/1.1 连接带来了更多的复杂性和开销。为此，谷歌在 2010 年代初实施了一个实验性协议 **SPDY**。鉴于SPDY的成功，HTTP/2也采用了SPDY作为整个方案的蓝图进行开发。`HTTP/2 于 2015 年 5 月正式标准化`。

- **二进制分帧**。HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，多个帧之间可以乱序发送，**根据帧首部的流（比如每个流都有自己的id）表示可以重新组装**；

  <center><img src="assets/image-20220909194902167.png" width="80%"></center>

- **多路复用**。在共享TCP链接的基础上同时发送请求和响应，将一个request/response作为一个**stream**，每个流都有独一无二的标志和优先级，并将一个stream根据负载分为多种类型的**frame**（例如 header frame，data frame等），在同一条connection之上可以混合发送分属于不同stream的frame，来自不同流的帧可以通过帧头的标志来关联和组装起来。**多路复用解决了 HTTP 层的队头阻塞，但仍然存在 TCP 层的队头阻塞**；

  TCP队头阻塞（head-of-line blocking）发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止

  HTTP队头阻塞是由pipeline引起的，pipeline要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。

  <center><img src="assets/image-20220909200032579.png" ></center>

- **头部压缩HPACK**，由于一些请求在一组请求中通常是相似的，因此这消除了传输数据的重复和开销。使用一份索引表来定义常用的 HTTP Header，**通讯双方各自cache一份header fields表**，既避免了重复header的传输，又减小了需要传输的大小：

  <center><img src="assets/image-20220909193635445.png" ></center>

- **服务器推送**，服务器可以额外的向客户端推送资源，而无需客户端明确的请求。在浏览器刚请求 `HTML` 的时候，服务端会把某些资源存在一定的关联性 `JS、CSS` 等文件等静态资源主动发给客户端，这样**客户端可以直接从本地加载这些资源**，不用再通过网络再次请求，以此来达到节省浏览器发送request请求的过程。

  使用服务器推送：

  ```html
  # 静态 Link 标签法
  <link rel="preload" href="/css/styles.css" as="style">
  或
  #  HTTP 头表示法
  Link: </css/styles.css>; rel=preload; as=style，
  </img/example.png>; rel=preload; as=image
  ```

  可以看到服务器**initiator**中的push状态表示这是服务端进行主动推送：

  <center><img src="assets/image-20220909195749084.png" ></center>

  对于主动推送的文件势必会带来多余或已经浏览器已有一份的文件，客户端使用一个简洁的 **Cache Digest** 来告诉服务器，哪些东西已经在缓存，因此服务器也就会知道哪些是客户端所需要的。



#### HTTP 3.0

在限定条件下，TCP下解决队头阻塞的问题相当困难，但是随着互联网的爆炸式发展，更高的稳定性和安全性需要得到满足，谷歌在2016年11月国际互联网工程任务组(IETF)召开了第一次**QUIC**（Quick UDP Internet Connections）工作组会议，制定的一种**基于UDP的低时延的互联网传输层协议**，HTTP-over-QUIC于2018年11月更名为HTTP/3。

（1）**0-RTT 握手**

**tcp中** 客户端发送syn包(syn seq=x)到服务器, 服务器接收并且需要发送(SYN seq =y; ACK x+1)包给客户端，客户端向服务器发送确认包ACK(seq = x+1; ack=y+1)，至此客户端和服务器进入ESTABLISHED状态，完成三次握手。

而HTTP3.0只需要进行一次握手就可以进行通信，如果缓存ServerConfig，甚至可以不用握手就直接通信。

**1-RTT**

1. 客服端使用私钥 a 然后选择一个公开的加密数 X ，通过计算得出 a*X = A, 将X 和 A发送给服务端；
2. 服务端使用私钥 b，通过计算得出 b*X = B, 将B发送给客户端；
3. 客户端使用ECDH生成通讯密钥 key = a\*B = a\*(b\*X)；
4. 服务器使用ECDH生成通讯密钥 key = b\*A = b\*(a\*X)。

**0-RTT**

0-RTT则是**客户端缓存了 ServerConfig**（B=b*X），下次建连直接使用缓存数据计算通信密钥：

- 客户端：使用私钥，选择公开的大数 X，计算 A=c\*X，将 A 和 X 发送给服务器，也就是 Client Hello 消息后，客户端直接使用缓存的 B 计算通信密钥 KEY = c\*B = c\*b\*X，加密发送应用数据；
- 服务器：根据 Client Hello 消息计算通信密钥 key = b\*A = b\*(c\*X)。

客户端不需要经过握手直接**通过缓存的B生成key**就可以发送应用数据。

再来思考一个问题：假设攻击者记录下所有的通信数据和公开参数A1，A2，一旦服务器的随机数 b（私钥）泄漏了，那之前通信的所有数据就都可以破解了。**为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证前向安全性**。



（2）**有序交付**

QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，QUIC 在每个数据包都设有一个 offset 字段（偏移量），**接收端根据 offset 字段就可以对异步到达的数据包进行排序了**，保证了有序性。



（3）**队头堵塞**

HTTP/2 之所以存在 TCP 层的队头阻塞，是因为所有请求流都共享一个滑动窗口，TCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。**QUIC中给每个请求流都分配一个独立的滑动窗口**。

<center><img src="assets/image-20220909203430596.png" ></center>

A 请求流上的丢包不会影响 B 请求流上的数据发送。但是，对于每个请求流而言，也是存在队头阻塞问题的，也就是说，虽然 QUIC 解决了 TCP 层的队头阻塞，但仍然存在单条流上的队头阻塞。这就是 QUIC 声明的无队头阻塞的多路复用。



（4）**连接迁移**

**当客户端切换网络时，和服务器的连接并不会断开，仍然可以正常通信**，对于 TCP 协议而言，这是不可能做到的。因为 TCP 的连接基于 4 元组：源 IP、源端口、目的 IP、目的端口，只要其中 1 个发生变化，就需要重新建立连接。但 **QUIC 的连接是基于 64 位的 Connection ID**，网络切换并不会影响 Connection ID 的变化，连接在逻辑上仍然是通的。

<center><img src="assets/image-20220909203638879.png" ></center>

假设客户端先使用 IP1 发送了 1 和 2 数据包，之后切换网络，IP 变更为 IP2，发送了 3 和 4 数据包，服务器根据数据包头部的 Connection ID 字段可以判断这 4 个包是来自于同一个客户端。QUIC 能实现连接迁移的根本原因是底层使用 **UDP 协议就是面向无连接**的。



#### 对比

<center><img src="assets/image-20220909203806672.png" ></center>



### HTTP 1.1有点慢，优化方法

优化方法主要有三种：

<center><img src="assets/2e00f64b8e2fafb7691f37e036ae18e8.png" width="80%"></center>

第一个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。

第二个思路是，减少 HTTP 请求的次数，有以下的方法：

- 将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；
- 将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；
- 按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。

第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。




#### 避免发送 HTTP 请求-cache

客户端要向服务器发送请求的。但是，对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

所以，避免发送 HTTP 请求的方法就是通过**缓存技术**，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。

那缓存是如何做到的呢？

**客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。**

这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本次磁盘的速度肯定比网络请求快得多，如下图：

<center><img src="assets/7d81f7635abdcfcf26e7bdb9c8cd5bf0.png" width="80%"></center>

**服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求**。

如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？

很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？

只需要客户端在重新发送请求时，在请求的 **Etag** 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。

- 如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源；
- 如果相同，说明客户端的缓存还是可以继续使用的，那么服务器仅返回不含有包体的 304 Not Modified 响应，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时。

<center><img src="assets/f101ebb9911284c8f12dad7cc3459ac1.png" width="80%"></center>

缓存真的是性能优化的一把万能钥匙，小到 CPU Cache、Page Cache、Redis Cache，大到 HTTP 协议的缓存。



#### 减少 HTTP 请求次数

减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：

- *减少重定向请求次数*；
- *合并请求*；
- *延迟发送请求*；

##### 减少重定向请求次数
服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。

那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。

另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：
<center><img src="assets/49ed0eda7283f0f0e8d3a05d4fe683ef.png" width="80%"></center>

如果**重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了**，如下图：

<center><img src="assets/e3949b4fec3b849b388b1c5767fadfaa.png" width="80%"></center>

而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：

<center><img src="assets/9f4dd4dabea718da631e448eb05fb484.png" width="80%"></center>

除了 `302` 重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：

<center><img src="assets/3cfb2737b2201d367e5dd21ad8b323b1.png" width="80%"></center>

其中，`301` 和 `308` 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。



##### 合并请求

如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。

另外由于 HTTP/1.1 是请求响应模型，**如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接**，那么如果合并了请求，也就**会减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间**。

接下来，具体看看合并请求的几种方式。

有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 CSS Image Sprites 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。

<center><img src="assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70.png" width="80%"></center>

这种方式就是通过**将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销**。

除了将小图片合并成大图片的方式，还可以使用**精灵图**，通过移动精灵图的位置显示不同的图片。

还有服务端使用 webpack 等打包工具**将 js、css 等资源合并打包成大文件**，也是能达到类似的效果。

另外，还可以**将图片的二进制数据用 base64 编码后，以 URL 的形式潜入到 HTML 文件，跟随 HTML 文件一并发送**。

```html
<image src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA ... />
```

这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片，就不用再发起图片相关的请求，这样便减少了请求的次数。

<center><img src="assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20220912141808143.png" width="80%"></center>

可以看到，合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。

但是这样的合并请求会带来新的问题，当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，这显然带来了额外的网络消耗。



##### 延迟发送请求

不要一口气吃成大胖子，一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「**按需获取**」的方式，来减少第一时间的 HTTP 请求次数。

请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。





#### 减少 HTTP 响应的数据大小
对于 HTTP 的请求和响应，通常 HTTP 的响应的数据大小会比较大，也就是服务器返回的资源会比较大。

于是，我们可以考虑对响应的资源进行压缩，这样就可以减少响应的数据大小，从而提高网络传输的效率。

压缩的方式一般分为 2 种，分别是：

- 无损压缩；

- 有损压缩；

  

##### 无损压缩

**无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码**。

首先，我们针对代码的语法规则进行压缩，因为通常代码文件都有很多换行符或者空格，这些是为了帮助程序员更好的阅读，但是机器执行时并不要这些符，把这些多余的符号给去除掉。

接下来，就是无损压缩了，需要对原始资源建立统计模型，利用这个统计模型，将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示，生成二进制比特序列一般是「霍夫曼编码」算法。

**gzip 就是比较常见的无损压缩**。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 Accept-Encoding 字段告诉服务器：

```html
Accept-Encoding: gzip, deflate, br
```

服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的 content-encoding 字段告诉客户端该资源使用的压缩算法。

```html
content-encoding: gzip
```

gzip 的压缩效率相比 Google 推出的 **Brotli** 算法还是差点意思，也就是上文中的 br，所以如果可以，服务器应该选择压缩效率更高的 br 压缩算法。



##### 有损压缩

与无损压缩相对的就是有损压缩，**经过此方法压缩，解压的数据会与原始数据不同但是非常接近**。

有损压缩**主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片**。

可以通过 HTTP 请求头部中的 Accept 字段里的「 q 质量因子」，告诉服务器**期望的资源质量**。

```html
Accept: audio/*; q=0.2, audio/basic
```

关于图片的压缩，目前压缩比较高的是 Google 推出的 **WebP** 格式，它与常见的 Png 格式图片的压缩比例对比如下图：

<center><img src="assets/19bce8a5943f3113e43cbcf6a0130553.png" width="80%"></center>

可以发现，相同图片质量下，WebP 格式的图片大小都比 Png 格式的图片小，所以对于大量图片的网站，可以考虑使用 WebP 格式的图片，这将大幅度提升网络传输的性能。

关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。

比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是**只需要在一个静态的关键帧，使用增量数据来表达后续的帧**，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。






## Https

### 基本介绍

**HTTP 存在的问题**

没有加密，无法保证通信内容不被窃听。

没有报文完整性验证，无法确保通信内容在传输中不被改变。

没有身份鉴别，无法让通信双方确认对方身份。

HTTP over SSL，在 HTTP 传输上增加了传输层安全性(TLS)或安全套接字层(SSL)，**通过信息加密**、**数据完整性校验**、**身份鉴别**为 HTTP 事务提供安全保证。SSL 会对数据进行加密并把加密数据送往 TCP 套接字，在接收方，SSL 读取 TCP 套接字的数据并解密，把数据交给应用层。

<center><img src="assets/image-20220909204555682.png" ></center>

HTTPS 采用混合加密机制，使用非对称加密传输对称密钥保证传输安全，使用对称加密保证通信效率。每一个`密钥对(key pairs)` 都有一个 `私有密钥(private key)` 和 `公有密钥(public key)`，私有密钥是独有的，一般位于服务器上，用于解密由公共密钥加密过的信息；公有密钥是公有的，与服务器进行交互的每个客户端都可以持有公有密钥，用公钥加密的信息只能由私有密钥来解密。

当我们申请域名证书，SSL会有一个pem证书和key私钥，pem证书包含数字签名和公钥。



### 证书文件

证书相关文件有多种格式，常见格式：`.crt`，`.key`，`.req`，`.csr`，`.pem`，`.der`。

- `xx.crt`：证书文件 (Certificate)
- `xx.key`：私钥文件
- `xx.req`：请求文件 
- `xx.csr`：请求文件  (Certificate Signing Request)
- `xx.pem`：证书文件为 `pem` 格式（文本文件）
- `xx.der`：证书文件为 `der` 格式（二进制文件）

实际上，上述文件的扩展名可以随意命名。只是为了容易理解文件的功能而选择大家都认识的命名方式。但是，上述文件是有格式的，只能是 `pem` 格式或者 `der` 格式。使用什么格式的文件取决于需求。

`pem` 格式的文件为文本文件，内容分别为：

证书文件：

```bash
-----BEGIN CERTIFICATE-----
-----END CERTIFICATE-----
```

私钥文件：

```bash
-----BEGIN RSA PRIVATE KEY-----
-----END RSA PRIVATE KEY-----
```

请求文件：

```bash
-----BEGIN CERTIFICATE REQUEST-----
-----END CERTIFICATE REQUEST-----   
```



### 证书种类

证书分为**根证书、服务器证书、客户端证书**。根证书文件（`ca.crt`）和根证书对应的私钥文件（`ca.key`）由 CA（证书授权中心，国际认可）生成和保管。

客户端会有一个信任库，里面保存了该客户端信任的CA（证书签发机构）的证书，如果收到的证书签发机构不在信任库中，则客户端会提示用户证书不可信。

若客户端是浏览器，各个浏览器都会内置一些可信任的证书签发机构列表，在浏览器的设置中可以看到。



### 证书内容

一个数字证书通常包含了：

- 公钥；
- 持有者信息；
- 证书认证机构（CA）的信息；
- CA 对这份文件的数字签名及使用的算法；
- 证书有效期；
- 还有一些其他额外信息；





### 服务器获取证书步骤和客户端验证步骤

服务器获取证书：

1. 服务器生成自己的私钥；
2. 服务器使用**私钥**生成请求文件（`server.req`），请求文件中包含服务器的相关信息，比如域名、公钥、组织机构等；
3. 服务器将 `server.req` 发送给 CA。CA 验证服务器合法后，使用 `ca.key` 和 `server.req` 生成证书文件（`server.crt`），将请求文件中的信息进行Hash计算，得到一个Hash值，使用ca的私钥将该Hash值进行加密，生成 Certificate Signature，也就是 CA 对证书做了签名，最后将 Certificate Signature 添加在文件证书上，形成数字证书；
4. CA 将证书文件（`server.crt`）发送给服务器。

由于`ca.key` 和 `ca.crt` 是一对，`ca.crt` 文件中包含公钥，因此 `ca.crt` 可以验证 `server.crt`是否合法——使用**公钥**验证证书的签名。

客户端验证证书：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。
  



### 证书链

但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：

<center><img src="assets/image-20220909213523926.png" ></center>

对于这种三级层级关系的证书的验证过程如下：

- 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书；
- 请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的；
- “GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

在这三个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。

这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：

<center><img src="assets/image-20220909213721266.png" ></center>

最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？

这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。





### 自签名证书

我们的网页要想使用HTTPS访问，就必须向证书机构去申请签发，并放在Nginx服务器下。但如果只是企业内部使用，不是给公众使用，也可以自行颁发自签名证书，比如K8S集群中就可以自行签发证书完成HTTPS双向认证。

一下以openssl来进行创建证书相关文件。

#### 生成根证书

生成这一些列证书之前，我们需要先生成一个CA根证书，然后由这个CA根证书颁发服务器公钥证书和客户端公钥证书。为了验证根证书颁发与验证客户端证书这个逻辑，我们使用根证书生成两套不同的客户端证书，然后同时用两个客户端证书来发送请求，看服务器端是否都能识别。

```bash
（1）创建根证书私钥：
openssl genrsa -out ca.key 1024

（2）创建根证书请求文件：
openssl req -new -out ca.csr -key ca.key
后续参数请自行填写，下面是一个例子：
Country Name (2 letter code) [XX]:cn
State or Province Name (full name) []:bj
Locality Name (eg, city) [Default City]:bj
Organization Name (eg, company) [Default Company Ltd]:alibaba
Organizational Unit Name (eg, section) []:test
Common Name (eg, your name or your servers hostname) []:root
Email Address []:a.alibaba.com
A challenge password []:
An optional company name []:

（3）创建根证书：
openssl x509 -req -in ca.csr -out ca.crt -signkey ca.key -CAcreateserial -days 3650
```

在创建证书请求文件的时候需要注意三点，下面生成服务器请求文件和客户端请求文件均要注意这三点： 

- 根证书的Common Name填写root就可以，所有客户端和服务器端的证书这个字段需要填写域名，一定要注意的是，根证书的这个字段和客户端证书、服务器端证书不能一样； 
- 其他所有字段的填写，根证书、服务器端证书、客户端证书需保持一致 最后的密码可以直接回车跳过。

经过上面三个命令行，我们最终可以得到一个签名有效期为10年的根证书root.crt，后面我们可以用这个根证书去颁发服务器证书和客户端证书。





#### 生成自签名服务器端证书

```bash
（1）生成服务器端证书私钥：
openssl genrsa -out server.key 1024

（2） 生成服务器证书请求文件，过程和注意事项参考根证书，本节不详述：
openssl req -new -out server.csr -key server.key

（3） 生成服务器端公钥证书
openssl x509 -req -in server.csr -out server.crt -signkey server.key -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650
```

经过上面的三个命令，我们得到：

server.key：服务器端的秘钥文件 server.crt：有效期十年的服务器端公钥证书，使用根证书和服务器端私钥文件一起生成



#### 生成自签名客户端证书

```bash
（1）生成客户端证书秘钥：
openssl genrsa -out client.key 1024
openssl genrsa -out client2.key 1024

（2） 生成客户端证书请求文件，过程和注意事项参考根证书，本节不详述：
openssl req -new -out client.csr -key client.key
openssl req -new -out client2.csr -key client2.key

（3） 生客户端证书
openssl x509 -req -in client.csr -out client.crt -signkey client.key -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650
openssl x509 -req -in client2.csr -out client2.crt -signkey client2.key -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650


（4） 生成客户端p12格式证书，需要输入一个密码，选一个好记的，比如123456
openssl pkcs12 -export -clcerts -in client.crt -inkey client.key -out client.p12
openssl pkcs12 -export -clcerts -in client2.crt -inkey client2.key -out client2.p12
```

重复使用上面的三个命令，我们得到两套客户端证书： client.key / client2.key： 客户端的私钥文件 client.crt / client2.key： 有效期十年的客户端证书，使用根证书和客户端私钥一起生成 client.p12/client2.p12：客户端p12格式，这个证书文件包含客户端的公钥和私钥，主要用来给浏览器访问使用。



#### Java API调用

由于使用的是自签名证书，使用ApacheHttpClient去调用的话，需要将服务器证书加入可信任证书库中，才能成功调用，也可以在代码中简单忽略证书。

```bash
cd $JAVA_HOME
sudo ./bin/keytool -import -alias ttt -keystore cacerts -file /Users/fred/temp/cert5/server.crt
```

将服务器端公钥证书设置为可信证书后，使用以下代码可以直接发起带客户端证书的HTTPS请求：

```java
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContexts;
import org.apache.http.util.EntityUtils;

import javax.net.ssl.SSLContext;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.security.KeyStore;

public class HttpClientWithClientCert {

    private final static String PFX_PATH = "/Users/fred/temp/cert5/client.p12";    //客户端证书路径
    private final static String PFX_PWD = "123456";    //客户端证书密码

    public static String sslRequestGet(String url) throws Exception {
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        InputStream instream = new FileInputStream(new File(PFX_PATH));
        try {
            keyStore.load(instream, PFX_PWD.toCharArray());
        } finally {
            instream.close();
        }
        SSLContext sslcontext = SSLContexts.custom().loadKeyMaterial(keyStore, PFX_PWD.toCharArray()).build();
        SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext
                , new String[] { "TLSv1" }    // supportedProtocols ,这里可以按需要设置
                , null    // supportedCipherSuites
                , SSLConnectionSocketFactory.getDefaultHostnameVerifier());

        CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();
        try {
            HttpGet httpget = new HttpGet(url);
            //httpget.addHeader("host", "integration-fred2.fredhuang.com");// 设置一些heander等
            CloseableHttpResponse response = httpclient.execute(httpget);
            try {
                HttpEntity entity = response.getEntity();
                String jsonStr = EntityUtils.toString(response.getEntity(), "UTF-8");//返回结果
                EntityUtils.consume(entity);
                return jsonStr;
            } finally {
                response.close();
            }
        } finally {
            httpclient.close();
        }
    }

    public static void main(String[] args) throws Exception {
        System.out.println(System.getProperty("java.home"));
        System.out.println(sslRequestGet("https://integration-fred2.fredhuang.com"));
    }

}
```



### cfssl的使用

除了openssl之外，还有一种cfssl也可以达到自签名证书的效果。

1. **创建一个根证书json文件**：

   ```json
   [root@devops cfssl]# cfssl print-defaults csr > ca-csr.json
   [root@devops cfssl]# vim ca-csr.json 
   {
     "CN": "kubernetes",
     "hosts": [],
     "key": {
         "algo": "rsa",
         "size": 2048
     },
     "names": [
       {
         "C": "CN",
         "ST": "Hubei",
         "L": "Wuhan",
         "O": "k8s",
         "OU": "systemGroup"
       }
     ],
     "ca": {
             "expiry": "87600h"
     }
   }
   ```

   - CN： Common Name，浏览器使用该字段验证网站是否合法，一般写的是域名，浏览器使用该字段验证网站是否合法，**K8S中用作用户名**；
   - hosts：可以使用的主机，不写的话代表所有；
   - key：生成证书的算法；
   - `names`：一些其它的属性：
     - C：Country， 国家；
     - ST：State，州，省；
     - L： Locality，地区，城市；
     - O：Organization Name，组织名称，公司名称；（K8S中用作组名）
     - OU：Organization Unit Name，组织单位名称，公司部门。

2. **生成CA证书**

   ```bash
   [root@devops cfssl]# cfssl gencert -initca ca-csr.json  | cfssljson -bare ca
   [root@devops cfssl]# ls
   ca.csr  ca-csr.json  ca-key.pem  ca.pem
   ```

   生成了ca.csr, ca-key.pem, ca.pem 三个文件

3. 创建一个服务器证书json文件：

   ```json
   [root@devops cfssl]# vim server-csr.json
   {
     "CN": "kubernetes",
     "hosts": [
       "127.0.0.1",
       "192.168.10.11",
       "192.168.10.12",
       "192.168.10.13"
     ],
     "key": {
       "algo": "rsa",
       "size": 2048
     },
     "names": [{
       "C": "CN",
       "ST": "Hubei",
       "L": "Wuhan",
       "O": "k8s",
       "OU": "systemGroup"
     }]
   }
   ```

4. 根据ca.key(ca私钥)和ca.crt(ca证书)生成服务器证书：

   ```bash
   [root@devops cfssl]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server
   [root@devops cfssl]# ls
   ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem  server.csr  server-csr.json  server-key.pem  server.pem
   ```





### 认证方式和TLS握手(※)

https有两种认证方式：单向验证和双向验证，而**使用哪一种，是由服务器决定的**。

#### 单向认证

单向验证是指通信双方中一方验证另一方是否合法。通常是指**客户端验证服务器**。

- 客户端需要：`ca.crt`
- 服务器需要：`server.crt`，`server.key`

**HTTPS 流程(TLS4次握手)**：

>HTTPS 是应用层协议，**需要先完成 TCP 连接建立，然后走 TLS 握手过程后**，才能建立通信安全的连接。不同的密钥交换算法，TLS 的握手过程可能会有一些区别。
>
>以RSA的握手为例。

① 客户发送它支持的密码套件列表、一个不重数、SSL/TLS协议版本列表。不重数就是在协议的生存期只使用一次的数，用于防止重放攻击(端点鉴别)，每个 TCP 会话使用不同的不重数，可以使加密密钥不同，重放记录无法通过完整性检查。

② 服务器将SSL/TLS版本、一个不重数、密码套件列表中的一个密码套件、证书(证书包含公钥)发送给客户。密码套件基本的形式是「**密钥交换算法(RSA) + 签名算法(RSA) + 对称加密算法(AES) + 摘要算法(SHA384)**」

③ 客户通过 CA(`Certificate Authority`，证书认证机构) 提供的ca.crt验证证书，成功后提取证书中的公钥，生成一个前主密钥 PMS(pre-master secret) 并使用公钥加密并发送给服务器。验证主要是：

- 证书是否过期；
- 发型服务器证书的CA是否可靠；
- 返回的公钥是否能正确解开返回证书中的数字签名；
- 服务器证书上的域名是否和服务器的实际域名相匹配；
- 验证通过后，将继续进行通信，否则，终止通信

服务器和客户端使用相同的密钥导出函数，独立的根据PMS和两个不重数中计算出主密钥MS。MS被切分为一个加密密钥和一个MAC密钥。当选择的对称密钥使用CBC时，两个初始向量也从MS获得，分别用于客户端和发送端。对每个记录附加一个MAC用于完整性检查，然后加密“记录+MAC”。MAC是数据+MAC密钥+当前序号的散列。序号是保证记录数据流不被第三方扰乱，接收方通过发送方的序号，通过在MAC的计算中包括适当的序号，验证记录的数据完整性。

然后客户端把之前发送的数据+数据的摘要(报文鉴别码Mac)进行加密，发送给服务器做一个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。

④服务器用私钥得到PMS，和客户端一样从MS中获取加密密钥和Mac密钥，也将之前发送的数据+数据的摘要(报文鉴别码Mac)进行加密，发送给客户端做一个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。



**应用：**

我们平时使用 PC 上网时使用的就是单向验证的方式。即，我们验证我们要访问的网站的合法性。PC 中的浏览器（火狐、IE、chrome等）已经包含了很多 CA 的根证书（`ca.crt`）。当我们访问某个网站（比如：[https://www.baidu.com](https://link.zhihu.com/?target=https%3A//www.baidu.com/)）时，网站会将其证书（`server.crt`）发送给浏览器，浏览器会使用 `ca.crt` 验证 `server.crt` 是否合法。如果发现访问的是不合法网站，浏览器会给出提示。

>现实中，有的公司会使用自签发证书，即公司自己生成根证书（`ca.crt`）。如果我们信任此网站，那么需要手动将其证书添加到系统中。



#### 双向认证

单向验证过程中，客户端会验证自己访问的服务器，服务器对来访的客户端身份不做任何限制。**如果服务器需要限制客户端的身份，则可以选择开启服务端验证，这就是双向验证**。从这个过程中我们不难发现，**使用单向验证还是双向验证，是服务器决定的。**

一般而言，我们的服务器都是对所有客户端开放的，所以**服务器默认都是使用单向验证**。如果你使用的是Tomcat服务器，在配置文件server.xml中，配置Connector节点的clientAuth属性即可。若为true，则使用双向验证，若为false，则使用单向验证。如果你的服务，**只允许特定的客户端访问**，那就需要使用双向验证了。

双向验证是指通信双方需要互相验证对方是否合法。服务器验证客户端，客户端验证服务器。

- 客户端需要：`ca.crt`，`client.crt`，`client.key`
- 服务器需要：`ca.crt`，`server.crt`，`server.key`

**HTTPS流程（TLS4次握手）：**

双向验证基本过程与单向验证相同，不同在于：

- 第二次握手：服务器第一次回应客户端的**SeverHello**消息中，会**要求客户端提供“客户端的证书**”

- 第三次握手：客户端验证完服务器证书后的回应内容中，会增加两个信息：

  - 客户端的证书
  - 客户端证书验证消息（**CertificateVerifymessage**）：客户端将之前所有收到的和发送的消息组合起来，并用hash算法得到一个hash值，然后用客户端**密钥库**的**私钥**对这个hash进行签名，这个签名就是**CertificateVerify message**

- 第四次握手：服务器收到客户端证书后：

  - 确认这个证书是否在自己的**信任库**中（当然也会校验是否过期等信息），如果验证不通过则会拒绝连接；
  - 用**客户端证书中的公钥**去验证收到的证书验证消息中的签名。这一步的作用是为了确认证书确实是客户端的。

  

所以，**在双向验证中，客户端需要用到密钥库，保存自己的私钥和证书，并且证书需要提前发给服务器，由服务器放到它的信任库中。**这一点至关重要，因为之前没想通这一点，导致我看K8S的kubeconfig的操作一脸懵逼。



**应用：**

双向验证通常用于支付系统中，比如支付宝。我们在使用支付宝时必须下载数字证书，该证书就是支付宝颁发给针对我们这台机器的证书，我们只能使用这台机器访问支付宝。如果换了机器，那么需要重新申请证书。





### RSA握手具体分析

<center><img src="assets/cf6df904729f4f3d5427ddd47efcb04e.png" width="80%"></center>

#### TLS 第一次握手

客户端首先会发一个「**Client Hello**」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。

<center><img src="assets/8705afa13ff53aa23b106899de8fc19c.png" ></center>

消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（Client Random）**，这个随机数会被服务端保留，它是生成主密钥MS的材料之一。

#### TLS 第二次握手
当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（Server Random）。

接着，返回「**Server Hello**」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。
<center><img src="assets/2233749a2b71b876383b2613852eb029.png" ></center>

可以看到，服务端选择的密码套件是 “**Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256**”。

这个密码套件是有固定格式和规范的。基本的形式是「**密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法**」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：

- 由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；
- 握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；
- 摘要算法 SHA384 用于消息认证和产生随机数；

就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。

那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。

然后，服务端为了证明自己的身份，会发送「**Server Certificate**」给客户端，这个消息里含有数字证书。

<center><img src="assets/94d8a96e1cb6f9a9a521da9a80c9cfbe.png" ></center>

随后，服务端发了「**Server Hello Done**」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。

<center><img src="assets/f2f8496fe4448a97e7ee82aca4314ac2.png" ></center>



#### TLS 第三次握手

客户通过 CA(`Certificate Authority`，证书认证机构) 提供的ca.crt验证证书，验证主要是：

- 证书是否过期；
- 发型服务器证书的CA是否可靠；
- 返回的公钥是否能正确解开返回证书中的数字签名；
- 服务器证书上的域名是否和服务器的实际域名相匹配；
- 验证通过后，将继续进行通信，否则，终止通信。

成功后提取证书中的公钥，生成一个前主密钥 PMS 并使用公钥加密并通过「**Change Cipher Key Exchange**」消息传给发送给服务器。

<center><img src="assets/image-20220909214057467.png" ></center>

**客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master**。于是，双方根据已经得到的三个随机数，生成**会话密钥/主密钥（Master Secret）**，MS被切分为两个加密密钥和两个MAC密钥。当选择的对称密钥使用CBC时，两个初始向量也从MS获得，分别用于客户端和发送端。对每个记录附加一个MAC用于完整性检查，然后加密“记录+MAC”。MAC是数据+MAC密钥+当前序号的散列。序号是保证记录数据流不被第三方扰乱，接收方通过发送方的序号，通过在MAC的计算中包括适当的序号，验证记录的数据完整性。

生成完会话密钥后，然后客户端发一个「**Change Cipher Spec**」，告诉服务端开始使用加密方式发送消息。

<center><img src="assets/fc84836ec655a8b3af419dec2f380912.png" ></center>

然后，客户端再发一个「**Encrypted Handshake Message（Finishd）**」消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。

<center><img src="assets/4c7823556e5a171d754368856ed5d3e3.png" ></center>

可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。



#### TLS 第四次握手

服务器也是同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。

最后，就用「会话密钥」加解密 HTTP 请求和响应了。



#### RSA 算法的缺陷
使用 RSA 密钥协商算法的最大问题是不支持前向保密。因为客户端传递的PMS（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

为了解决这一问题，于是就有了 DH 密钥协商算法，这里简单介绍它的工作流程。
<center><img src="assets/35fbbb560ef61c7501dc8f9cfe8e5fec.png" width="80%"></center>

客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各自的公钥，通过 TLS 握手双方交换各自的公钥，这样双方都有自己的私钥和对方的公钥，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。

DH 密钥交换过程中，即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是实时生成的，实现前向保密。

但因为 DH 算法的计算效率问题，后面出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 **ECDHE** 密钥协商算法。



### ECDHE握手具体分析

> 可以先去了解一下ECDHE算法。

我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：

<center><img src="assets/image-20220911201205328.png" ></center>

使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。

所以，E**CDHE 相比 RSA 握手过程省去了一个消息往返的时间**，这个有点「抢跑」的意思，它被称为是「TLS False Start」，跟「TCP Fast Open」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。

接下来，分析每一个 ECDHE 握手过程。


#### TLS 第一次握手

客户端首先会发一个「**Client Hello**」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（Client Random）**。

<center><img src="assets/9ff1c3c1740033f17c823c1b4b2dd2ab.png" ></center>

#### TLS 第二次握手

服务端收到客户端的「打招呼」，同样也要回礼，会返回「**Server Hello**」消息，消息面有服务器确认的 TLS 版本号，也给出了一个**随机数（Server Random）**，然后从客户端的密码套件列表选择了一个合适的密码套件。

<center><img src="assets/cef524cc58813e94b26fba92a9865468.png" width="80%"></center>

不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。

「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」

- 密钥协商算法使用 ECDHE；
- 签名算法使用 RSA；
- 握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；
- 摘要算法使用 SHA384；

接着，服务端为了证明自己的身份，发送「Certificate」消息，会把证书也发给客户端。

<center><img src="assets/0bd8d71eb375b3ef1cde897d2bf7b09a.png" width="80%"></center>

这一步就和 RSA 握手过程有很大到区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「**Server Key Exchange**」消息。

<center><img src="assets/a71c050db6188d74156c54b9ffff306d.png" width="80%"></center>

这个过程服务器做了三件事：

- **选择了名为 named_curve 的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；**
- **生成随机数作为服务端椭圆曲线的私钥，保留到本地；**
- **根据基点 G 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端。**
- **为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。**

随后，就是「Server Hello Done」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。
<center><img src="assets/d10501329c651f190ba1acc63f14d6d0.png" ></center>

至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：**Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥**，这几个信息很重要，是后续生成会话密钥的材料。



#### TLS 第三次握手

**客户端收到了服务端的证书后，自然要校验证书是否合法**，如果证书合法，那么服务端到身份就是没问题的。校验证书到过程，会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。

客户端会**生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥**，然后用「Client Key Exchange」消息发给服务端。

<center><img src="assets/cd6aa0e80e3a8e21914c6a4750033b72.png" ></center>

至此，**双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G**。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，x是一个共享密钥，但实际应用中，x 还不是最终的会话密钥。

还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？

最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的。

之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算出最终的会话密钥，安全性更高。

算好会话密钥后，客户端会发一个「Change Cipher Spec」消息，告诉服务端后续改用对称算法加密通信。
<center><img src="assets/ecbcfb1921b085caac076e044f3b1dd1.png" ></center>

接着，客户端会发「**Encrypted Handshake Message**」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。

<center><img src="assets/d1ff1da291957d8c34ad66022b170dc6.png" ></center>



#### TLS 第四次握手

最后，服务端也会有一个同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。





#### RSA和ECGHE握手的区别

- **RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密**；
- 使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，**客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间**；
- 使用 ECDHE， **在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息**，而 RSA 握手过程没有该消息；



### TLS 和 TCP 能同时握手

前面说了，**HTTPS 建立连接的过程，先进行 TCP 三次握手，再进行 TLS 四次握手**。

<center><img src="assets/image-20220911205418354.png" ></center>

但「HTTPS 中的 TLS 握手过程可以同时进行三次握手」，这个场景是可能存在的，但是一定要有前提条件。

- **如果开启了 TCP Fast Open 功能，那么建立第二次以后的通信过程，可以绕过 TCP 三次握手发送数据；**
- **TLSv1.2 握手过程基本都是需要四次，也就是需要经过 2-RTT 才能完成握手，然后才能发送请求，而 TLSv1.3 只需要 1-RTT 就能完成 TLS 握手**。

也就是说**如果客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3，且客户端和服务端已经完成过一次通信**，那么**HTTPS 中的 TLS 握手过程可以同时进行三次握手**。



#### TCP Fast Open
常规的情况下，如果要使用 TCP 传输协议进行通信，则客户端和服务端通信之前，先要经过 TCP 三次握手后，建立完可靠的 TCP 连接后，客户端才能将数据发送给服务端。

其中，TCP 的第一次和第二次握手是不能够携带数据的，而 TCP 的第三次握手是可以携带数据的，因为这时候客户端的 TCP 连接状态已经是 ESTABLISHED，表明客户端这一方已经完成了 TCP 连接建立。
<center><img src="assets/35bc3541c237686aa36e0a88f80592d4.png" ></center>

就算客户端携带数据的第三次握手在网络中丢失了，客户端在一定时间内没有收到服务端对该数据的应答报文，就会触发超时重传机制，然后客户端重传该携带数据的第三次握手的报文，直到重传次数达到系统的阈值，客户端就会销毁该 TCP 连接。

说完常规的 TCP 连接后，我们再来看看 TCP Fast Open。

TCP Fast Open 是为了绕过 TCP 三次握手发送数据，在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。

要使用 TCP Fast Open 功能，**客户端和服务端都要同时支持才会生效，而且开启了 TCP Fast Open 功能，想要绕过 TCP 三次握手发送数据，得建立第二次以后的通信过程**。

在客户端首次建立连接时的过程，如下图：

<center><img src="assets/7cb0bd3cde30493fec9562cbdb549f83.png" ></center>

具体介绍：

- **客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；**
- **支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 报文中的 Fast Open 选项以发回客户端；**
- **客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie**。

所以，第一次客户端和服务端通信的时候，还是需要正常的三次握手流程。随后，客户端就有了 Cookie 这个东西，它可以用来向服务器 TCP 证明先前与客户端 IP 地址的三向握手已成功完成。

对于客户端与服务端的后续通信，客户端可以在第一次握手的时候携带应用数据，从而达到绕过三次握手发送数据的效果，整个过程如下图：
<center><img src="assets/fc452688b9351e0cabf60212dde3f21e.png" ></center>

我详细介绍下这个过程：

- 客户端发送 SYN 报文，该报文可以携带「应用数据」以及此前记录的 Cookie；
- 支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：**如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「应用数据」递送给对应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「应用数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号**；
- 如果服务器接受了 SYN 报文中的「应用数据」，服务器可在握手完成之前发送「响应数据」，这就减少了握手带来的 1 个 RTT 的时间消耗；
- **客户端将发送 ACK 确认服务器发回的 SYN 以及「应用数据」，但如果客户端在初始的 SYN 报文中发送的「应用数据」没有被确认，则客户端将重新发送「应用数据」**；
- 此后的 TCP 连接的数据传输过程和非 TCP Fast Open 的正常情况一致。

所以，如果客户端和服务端同时支持 TCP Fast Open 功能，那么在完成首次通信过程后，后续客户端与服务端 的通信则可以绕过三次握手发送数据，这就减少了握手带来的 1 个 RTT 的时间消耗。


#### TLSv1.3

在最开始的时候，我也提到 TLSv1.3 握手过程只需 1-RTT 的时间，它到整个握手过程，如下图：

<center><img src="assets/1fd5ba4000f82613fdd70cab6da4b9cb.png" ></center>

TCP 连接的第三次握手是可以携带数据的，如果客户端在第三次握手发送了 TLSv1.3 第一次握手数据，是不是就表示「HTTPS 中的 TLS 握手过程可以同时进行三次握手」？。

不是的，因为服务端只有在收到客户端的 TCP 的第三次握手后，才能和客户端进行后续 TLSv1.3 握手。

TLSv1.3 还有个更厉害到地方在于**会话恢复机制**，在重连 TLvS1.3 只需要 0-RTT，用“**pre_shared_key**”和“**early_data**”扩展，在 TCP 连接后立即就建立安全连接发送加密消息，过程如下图：

<center><img src="assets/59539201f006d7dc0a06333617e5ea85.png" width="80%"></center>



#### TCP Fast Open + TLSv1.3
在前面我们知道，客户端和服务端同时支持 TCP Fast Open 功能的情况下，**在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据**。

如果 HTTPS 的 TLS 版本是 1.3，那么 **TLS 过程只需要 1-RTT**。

因此如果「TCP Fast Open + TLSv1.3」情况下，**在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的**。

如果基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，不仅 TLS 和 TCP 的握手过程是可以同时进行的，而且 HTTP 请求也可以在这期间内一同完成。






### TLS和SSL的区别

最新版本的 TLS 是 IETF（Internet Engineering Task Force，Internet 工程任务组）制定的一种新的协议，它建立在 `SSL 3.0` 协议规范之上，是 `SSL 3.0` 的后续版本。

TLS 的主要**目标是使 SSL 更安全**，并使协议的规范更精确和完善。TLS 在 SSL v3.0 的基础上，提供了一下增强内容：

1. 更安全的 MAC 算法
2. 更严密的警报
3. “灰色区域”规范的更明确的定义

主要区别如下：

1. **版本号：**TLS 记录格式与 SSL 记录格式相同，但版本号的值不同，TLS 的版本 1.0 使用的版本号为 SSL v3.1
2. **报文鉴别码：**SSL v3.0 和 TLS 的 MAC 算法及 MAC 计算的范围不同。
   - TLS 使用了 RFC-2140 定义的 HMAC 算法。HMAC 算法采用的是`异或运算`。
   - SSL v3.0 中，填充字节与密钥之间采用的是`连接运算`。

3. **伪随机函数：**TLS 使用了称为 PRF 的伪随机函数来将密钥扩展成数据块，是更安全的方式。

4. **报警代码：**TLS 支持几乎所有的 SSL v3.0 报警代码，而且 TLS 还补充定义了很多报警代码。

   如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等

5. **密文族和客户证书：**SSL v3.0 和 TLS 存在少量差别，即 TLS 不支持 Fortezza 密钥交换、加密算法和客户证书。

6. **certificate_verify 和 finished消息：**SSLv3.0 和 TLS 在用 `certificate_verify` 和 `finished` 消息计算 MD5 和 SHA-1 散列码时，计算的输入有少许差别，但安全性相当。

7. **加密计算：**TLS 与 SSLv3.0 在计算主密值（master secret）时采用的方式不同。

8. **填充**：用户数据加密之前需要增加的填充字节。
   - 在 SSL 中，填充后的数据长度要达到密文块长度的`最小整数倍`。
   - 而在 TLS 中，填充后的数据长度可以是密文块长度的`任意整数倍`（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。





### HTTPS 一定安全可靠吗？

这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。那么这个「中间人服务器」就获取了全部数据。

<center><img src="assets/94bc14be2138cbdaeb6db2c9644f4191.jpeg" width="80%"></center>

具体过程如下：

- 客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；
- 在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，客户端验证证书的真伪，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了；
- 在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了；
- 后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。

从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。

那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。
<center><img src="assets/image-20220911221054975.png" width="80%"></center>

如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。

所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那**不能怪 HTTPS ，得怪自己手贱**。



### 抓包工具

> **为什么抓包工具能截取 HTTPS 数据?**

抓包工具 Fiddler 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。

对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:

- 中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
- 中间人，作为服务端与真实客户端建立连接，这里会有**客户端信任服务端**的问题，也就是**服务端必须有对应域名的私钥**；

中间人要拿到私钥只能通过如下方式：

- 去网站服务端拿到私钥；
- 去CA处拿域名签发私钥；
- 自**己签发证书，且被浏览器信任**；

不用解释，抓包工具只能使用第三种方式取得中间人的身份。

使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。

**Fiddler 能够抓包的关键是客户端会往系统受信任的根证书列表中导入 Fiddler 生成的证书，而这个证书会被浏览器信任，也就是 Fiddler 给自己创建了一个认证中心 CA。**

客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

> **如何避免被中间人抓取数据？**

**我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站**，这样 HTTPS 数据就不会被中间人截取到了。

当然，我们**还可以通过 HTTPS 双向认证**来避免这种问题。一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。




> 可以参考K8S中的认证使用：:point_right: [https://blog.csdn.net/qq_44766883/article/details/126549242](https://blog.csdn.net/qq_44766883/article/details/126549242)
>
> 参考：
>
> - :point_right: [HTTPS实战之单向验证和双向验证 - 哈哈呵h - 博客园 (cnblogs.com)](https://www.cnblogs.com/yaowen/p/10448603.html)
> - :point_right: [SSL：证书文件 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/86926335)
> - :point_right: [ HTTPS双向认证（Mutual TLS authentication)_猥琐的刚的博客-CSDN博客_双向认证](https://blog.csdn.net/jzg5845201314/article/details/114646199)
>
> 最后推荐一个很厉害的网络博主：小林coding，很多内容都是从他那里学的，收益匪浅。





## RPC 和 HTTP

<center><img src="assets/image-20220909144807896.png" ></center>

首先，HTTP其是一个超文本传输协议，它基于 TCP/IP 来传输文本、图片、视频、音频等，HTTP 并不提供数据包的传输功能，而仅仅是**客户端和服务端约定好的一种通信格式**。因此HTTP 和 RPC 其实是两个维度的东西，HTTP是一种通信协议，而RPC是一种远程过程调用，调用方和接收方也需要约定一个通信格式，可以用 HTTP 协议，也可以是TCP、UDP以及自定义协议（一般选用TCP）。

另一方面，RPC和HTTP都是都是跨应用调用方法的解决方案，准确来说，RPC和Rest才是一种对立关系，RPC，所谓的远程过程调用 ，是**面向方法**的 ，REST：所谓的 Representational state transfer ，是**面向资源**的：

- HTTP协议，以其中的Restful规范为代表，其优势很大。它**可读性好，跨语言，跨平台**，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。但是HTTP也有其缺点，这是与其优点相对应的。首先是**有用信息占比少**，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是**效率低**，还是因为第七层的缘故。还有，其**可读性似乎没有必要**，因为我们可以引入网关增加可读性。此外，使用HTTP协议**调用远程方法比较复杂**，要封装各种参数名和参数值。

- RPC是远程过程调用，过程其实就是方法，它的理念就是**像调用本地方法一样调用远程方法，这个过程是应用间的内部过程**，**数据格式需要自己指定，因此牺牲可读性，且不能跨语言，但带来的效率提升、易用性是可取的**。RPC要求在调用方中放置被调用的方法的接口。**调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用**。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。

  首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。

  第二，动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：

  - 识别具体要调用的远程方法的IP、端口
  - 将调用方法的入参进行序列化
  - 通过通信将请求发送到远程的方法中

  这样，远程的服务就接收到了调用方的请求。它应该：

  - 反序列化各个调用参数
  - 定位到实际要调用的方法，然后输入参数，执行方法
  - 按照调用的路径返回调用的结果

  整个过程如下所示：

  <center><img src="assets/image-20220909151500386.png" ></center>

REST 接口更加规范，通用适配性要求高，建议**对外服务的接口都统一成 REST**。而**多系统之间的内部调用采用RPC**，主要是：①不用耗费太多精力去开发和维护多套的HTTP接口；②RPC的调用性能更高，有效信息多，效率高；③使用更加简单。

>RPC的了解推荐项目：https://github.com/he2121/MyRPCFromZero



## 密码技术

密码技术使发送方可以伪装数据，入侵者不能从截获到的数据中获得有效信息。

**对称加密算法：**

使用相同的加密密钥和解密密钥，运算速度快，但安全性差。使用对称密钥时，在通信信道上可以进行**一对一的双向保密通信**，每一方既可以用该密钥加密明文，也可以解密密文。这种保密通信仅限于持有此密钥的双方。

对称加密技术分为块密码和流密码。块密码被用在SSL中。

**块密码：**在块密码中，要加密的报文被处理为k比特的块，每个块被独立加密，采用一对一映射，k比特原文映射k比特密文。K数字越大则可能的排列数越多，越不能破解。但是K越大所要存储的输入表也越大越多，这是难以实现的。因此块密码通常使用函数模拟随机排列，将K比特再次分成多个组，对每个小分组（通过小型加密表）进行加密，然后把分组重新排序，再次加密，再重排加密，如此循环得到最后的密文。这是用**时间换空间**的处理，通过对单个小分组的多次加密，达到更高的保护性。一个算法的密钥决定了特性“小型表”的映射和该算法内部的排列。

当某些特定的位置总会出现特定的明文，那么加密后得到的密文如果相同，攻击者看到相同的密文可能会猜出明文，并且通过识别相同的密文快和利用支撑协议结构的知识，可能解密整个报文。因此需要加入一些随机性，让相同的明文翻译出的密文并不完全相同，块密码通过密码块链接（CBC）实现。基本思想是仅随第一个报文发送一个随机值，然后让发送方和接收方使用计算的编码块代替后继的编码块。具体如下：

1. 在加密报文或数据流之前，发送方生成一个随机的k比特串，称为初始向量，发送方以明文的方式将初始向量发送给接收方
2. 对第一个块，计算第一块明文与初始向量的异或，然后通过块密码算法运行得到相应的密文。并把密文当作下一个块的向量
3. 以上一个块的密文当作下一个块的向量，不断循环

接收方是倒着解密的， 根据发送方，上一个加密块会当作下一次的随机向量。先解密最后一个接受块，得到异或值和随机向量，而随机向量是上一个接受块，这样就得到最后一个明文。不断循环，从后向前解密，第一个接受快所需要的初始向量是明文发送。即使第三方得到初始向量，但是并不知道密钥同样无法破解。

**流密码：**每次加密都通过密钥生成一个密钥流，解密也是使用同一个密钥流，明文与同样长度的密钥流进行异或运算得到密文，密文与同样的密钥流进行异或运算得到明文。流密码算法是以“一次性密码本“为雏形演变出来的加密算法，一次性密码本算法很重要的一个特性就是密钥流使用的”一次性“，将密钥作为“内部状态“传入随机数生成器中，每次由随机数生成器生成随机的密钥流，然后明文和密文都使用相同的密钥流进行异或运算加密和解密。

常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES

**非对称加密算法：**

使用公钥进行加密，私钥进行解密，公钥是任何人都可以得知的，而私钥是通信双方独有的。运算速度慢，但是安全性好。最常见的公钥加密算法是 RSA，它使用两个大素数 p 和 q 生成密钥，pq 的值越大破解难度越大，但耗时也越长。使用公开密钥时，在通信信道上是**多对一的单向保密通信**，可以同时有很多客户利用公钥对报文加密后发送给服务器，服务器利用其私钥可以对收到的密文一一解密，但如果是反方向则行不通，例如网购时很多客户都向同一网站发送各自的信用卡信息。

常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）

**不可逆加密算法：**

一般使用hash来加密，通常不可还原。一般是将数据进行加密并于加密后的数据进行比较，若相等则表示正确。

常见的Hash算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1



### RSA数学原理

#### 获取两个不相等的质数pq

质数又称素数，在自然数中，除了1和自身外，不能被其他自然数整除。比如10以内的质数有：1，2，3，5，7。



#### 把p和q相乘，得到n

比如：n=61*53=3233，用二进制表示为：110010100001。

我们常说的RSA算法中的多少位，就是n用二进制表示后的位数，在我们例子就是12位。目前商用中一般都是2048位。

<center><img src="assets/image-20220911155815334.png" width="80%"></center>



#### 计算出小于n的自然数中，有多少数与n互质（欧拉函数）

如果两个数的最大公约数为1，那么我们说这两个数互质，记：GCD(a,b)=1。其中GCD表示两个数的最大公约数。

使用欧拉函数来判断是否互质：

- 情况1：如果n=1，那么与n互质的自然数只有1
  $$
  φ(n)=1
  $$

- 情况2：如果n是质数，那么与n互质的自然数有n-1个，
  $$
  φ(n)=n-1
  $$
  例：φ(7)=6例：*φ*(7)=6

- 情况3：如果n可以因式分解为两个互质数的乘积，则：
  $$
  φ(n)=φ(p)\times φ(q)=(p-1)\times (q-1) \\
  例：φ(56)=φ(7)*φ(8) = 6 * 7 = 42
  $$

- 情况4：如果n可以写成某个数的质数次幂(其中k为质数)，则：
  $$
  φ(n)=φ(p^k)=p^k-p^{k-1}=p^k(1-\frac 1p)  \\
  例：φ(49)=φ(7^2)=7^2 - 7^1 = 42
  $$

- 情况5：根据以上规律，总结出一个通用的公式：

$ \qquad n=p_1^{k^1} \times p_2^{k^2} \ldots p_r^{k^r} \quad 注：任意一个整数，都可以写成两个质数的乘积$
$ \qquad \Downarrow $
$ \qquad φ(n)=φ(p_1^{k^1}) \times φ(p_2^{k^2})\ldots φ(p_r^{k^r})$
$ \qquad \Downarrow $
$ \qquad φ(n)= p_1^{k^1}(1- \frac 1p_1) \times p_2^{k^2}(1- \frac 1p_2) \ldots p_r^{k^r}(1- \frac 1p_r)$
$ \qquad \Downarrow $
$ \qquad φ(n)=p_1^{k^1} \times p_2^{k^2}\ldots p_r^{k^r}\times (1- \frac 1p_1)\times(1- \frac 1p_2)\ldots(1- \frac 1p_n) $
$ \qquad \Downarrow $
$ \qquad φ(n)=n\times(1- \frac 1p_1)\times(1- \frac 1p_2)\ldots(1- \frac 1p_n) $

- 总结：通过欧拉函数最后的通式，我们发现**最后的结果只和n和p有关，和p的幂无关**，这点很重要，在我们用程序实现时，能够大大的简化我们的逻辑代码。

回到算法中，我们需要计算与n互质的个数，也就是求φ(n)，根据欧拉函数，计算过程如下：
$$
φ(n)=φ(3233)=φ(61)×φ(53)=60×52=3120
$$


#### 在1和φ(n)之间，选取一个随机质数e

即在1~3120中选取e=17。



#### 求e和φ(n)的模反元素d（裴蜀定理、扩展欧几里得算法）

模反元素也称为`模倒数`，可以写成 $a^{−1}≡b \ (mod \ n)$ 或  $ ab≡1 \ (mod \ n)$。（ab和1关于n同模）

如果两个正整数a和n互质，那么一定可以找到整数b，使得a*b与n相除，余数为1，记作：$ (a \times b) \% n = 1 \Rightarrow \frac {(a \times b) - 1} n = 1 $。

例：求3和11的模反元素
$$
\frac {(3 \times b) - 1} {11} =1  => b = 4
$$

- 通过上面的运算，我们可以算出一些简单数的模反元素，对于较大的数来说，我们需要引入新的计算工具：**裴蜀定理**，通过它，我们可以通过一个**二元一次方程**来得出模反元素。在求模反元素时，**给予二个整数a、b，必存在整数x、y使得ax + by = gcd(a,b)**，而我们真正要获取的是x的值。
- 定义：如果a与b互质，即GCD(a, b) = 1，二元一次方程$ ax + by = 1 $有一对正整数解，其中x即为a、b的模反元素。同理，上面的例子我们可以化简成这样：3x + 11y = 1
- 疑惑：对于**二元一次方程**，好像不可解（也可以说有无穷多个解），我们之前都是解方程组。即然定理已经解决，两个互素（质）数组成的二元一次方程有一对整数解，那肯定是能解，解法我们需要引入另一个数学工具：**扩展欧几里得算法**

扩展欧几里得算法这个算法其实就是上面我们求最大公约数时，用到的**辗转相除法+它的逆运算**，我们看个例子就明白是什么意思了

例1：求$ 47x + 30y = 1 $的解

解：使用辗转相除法，我们可以得到：
$$
47 = 30 \times 1 + 17 \  \\
30 = 17 \times 1 + 13  \ \\ 
17 = 13 \times 1 + 4   \ \ \ \\
13 = 4 \times 3 + 1  \ \ \ \ \ \\
4 = 1 \times 4 + 0 \ \ \ \ \ \
$$
我们可以得到GCD(47, 30) = 1，对到处第二行，我们移项处理：
$$
1 = 13 - 4 \times 3   \\
4 = 17 - 13 \times 1   \\
13 = 30 - 17 \times 1   \\
17 = 47 - 30 \times 1  \\
$$
我们把第二行代入第一行中：
$$
1 = 13 - \overbrace{(17 - 13 \times 1)}^4 \times 3   \\
 \Downarrow   \\
 1 = 4 \times 13 - 3 \times 17 \\
 \Downarrow \\
 1 = 4 \times \overbrace{(30 - 17)}^{13} - 3 \times s17 \\
 \Downarrow \\
 \ldots \\
 1 = (-7) \times 47 + 11 \times 30 \\

解得：x=-7(即为我们要求的模反元素d) \quad y = 11
$$
回到算法中，我们根据e=17和φ(n)=3120，得到一个二元一次方程：$ 17x + 3120y = 1 $，再根据扩展欧几里得算法，我们可以得到方程的解：$x = 2753 \quad 即：d = 2753$。



#### 把n和e封装成公钥，n和d封装成私钥

- 公钥：$ (3233, 17) $
- 私钥：$ (3233, 2753) $



#### 实例

私钥和公钥获取：

1. 取p=47, q=71；

2. 则n = p * q = 3337, Φ(n)=(p-1)(q-1)=3220；

3. 随机选择加密密钥e，e与Φ(n)互素，取e=79；

4. 79 * d=1(mod n)  =》 d = $101^9$；  

5. 公钥为(3337,79)，私钥为（3379,1019）

   

假设要加密的明文是m=6882326879666683：

- 首先，根据n的大小将m进行分组，这里我们把明文m分成六个组，即：m1=688, m2=232, m3=687, m4=966, m5=668, m6=003；
- 接着分别对各个分组进行加密运算，第一个分组加密为c1=$688^{79}$(mod 3337) = 1570，类似的，对其余各个分组分别进行加密运算，得到如下密文：c=1570 2756 2091 2276 2423 158；
- 解密时用私钥1019分别对明文进行解密运算，即：m1=$1570^{1019}$(mod 3337) = 688，对其余的密文用同样的计算方法就可以把密文恢复出来，即得到密文。



#### RSA参数的选择
p和q的选择：

- p和q要足够大

- p和q应为强素数。如p满足以下三个条件，即为强素数：

  （1）P-1有大素数因子r

  （2）P+1有大素数因子s

  （3）R-1有大素数因子t

- p和q的差不能太小
- p-1和q-1的最大公因数应很小

公钥e的选择：e不能太小；最好选择e为modΦ(n)的阶数，意思就是要使i的值尽量大才能使得ei≡ (mod Φ(n))成立。i等于(p-1)(q-1)/2是最好的。一般建议取e=$2^{16}$+1=65537





#### 代码

（1）质数判断
```tsx
import Gcd from './Gcd'
/**
 * 质数类
 */
class Prime {
    private static pNumArr: Array<number> = []
    /**
     * 判断一个数是否为质数
     * @param num 转入值
     */
    public static isPrimeNum(num: number): boolean {
        // 1和2都是质数
        if (num < 3) {
            return true
        }
        // i取开方，效率要比/2高出许多
        for (let i = 2; i <= Math.sqrt(num); i++) {
            if (num % i === 0) {
                return false
            }
        }
        return true
    }
    /**
     * 1. 任意两个质数构成互质关系，比如13和61。
    　　2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。
    　　3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。
    　　4. 1和任意一个自然数是都是互质关系，比如1和99。
    　　5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。
    　　6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。
     */
    public static coprime(n1: number, n2: number): boolean {
        // 保证n1比n2要大
        if (n2 > n1) {
            let tmp = n1
            n1 = n2
            n2 = tmp
        }
        // 两个数中, 有一个是1, 则两数互质
        if (n1 === 1 || n2 === 1) {
            return true
        }
        // 如果两数相邻, 则两数互质
        if (n1 - n2 === 1) {
            return true
        }
        // 如果大数为奇数, 则n1-n2 = 2, 则两数互质
        if (n1 % 2 === 1 && n1 - n2 === 2) {
            return true
        }
        // 如果较大的数为质数, 则两数互质
        if (this.isPrimeNum(n1)) {
            return true
        }
        // 有一个是质数, 别一个不为此数的倍数, 则两数互质
        if ((this.isPrimeNum(n1) || this.isPrimeNum(n2)) && n1 % n2 !== 0) {
            return true
        }
        // 如果两个数都为质数, 则两个数互质
        if (this.isPrimeNum(n1) && this.isPrimeNum(n2)) {
            return true
        }
        // 如果两个数的最大公约数为1, 则两个数互质
        if (Gcd.gcd(n1, n2) === 1) {
            return true
        }
        return false
    }
    /**
     * 获取该数下所有的质数
     * @param num 转入的数
     */
    public static getAllPrimeNum(num: number) {
        let arr = []
        for (let i = 1; i <= num; i++) {
            if (this.isPrimeNum(i)) {
                arr.push(i)
            }
        }
        return arr
    }

    /**
     * 把一个正整数分解为两个质数的乘积
     * @param num
     */
    public static break(num: number) {
        this.getBreakArr(num)
        return this.pNumArr
    }

    /**
     * 把一个正整数分解为两个质数的乘积(中间步骤)
     * @param num
     */
    private static getBreakArr(num: number) {
        // 获取该数/2的所有质数
        let arr = this.getAllPrimeNum(Math.floor(num / 2))
        // 能被这个数整除的最大质数
        let maxNum = 1
        for (let i = 0; i < arr.length; i++) {
            if (num % arr[i] === 0) {
                maxNum = arr[i]
            }
        }
        // 除数
        let divNum = num / maxNum
        if (maxNum !== 1) {
            this.pNumArr.push(maxNum)
            return this.break(divNum)
        } else {
            this.pNumArr.push(divNum)
            return maxNum
        }
    }
}

export default Prime
```



（2）欧拉函数计算
```tsx
import Prime from './Prime'
import Util from './Util'
/**
 * 欧拉函数
 */
class Euler {
    /**
     * 根据欧拉函数取与此数互质的个数
     * @param num 参数
     */
    public static getEulerNum(num: number) {
        Prime.break(num)
        let arr = Util.uniqueArr(Prime.break(num))
        let result = num
        for (let i = 0; i < arr.length; i++) {
            result *= 1 - 1 / arr[i]
        }
        return Math.floor(result)
    }
}

export default Euler
```



（3）最大公约数计算-欧几里得算法-辗转相除法

```tsx
/**
 * 最大公约数
 */
class Gcd {
    /**
     * 计算2个数的最大公约数
     * @param n1 数1
     * @param n2 数2
     */
    public static gcd(n1: number, n2: number): number {
        let s = Math.floor(n1 / n2)
        let y = n1 % n2
        // console.log(n1 + ' = ' + n2 + '*' + s + ' + ' + y)
        if (y === 0) {
            return n2
        } else {
            return this.gcd(n2, y)
        }
    }
    /**
     * 扩展欧几里德算法 - 求方程的解 （详细注释版）
     * 我们要求：47x + 30y = 1的解，下面为辗转相除法的步骤：
     * 47 = 30*1 + 17
     * 30 = 17*1 + 13
     * 17 = 13*1 + 4
     * 13 = 4*3 + 1
     *
     *
     * @param num1 数1
     * @param num2 数2
     */
    public static gcdEx(n1: number, n2: number): Array<number> {
        // 两数相除的商
        let q = Math.floor(n1 / n2)
        // 两数相除的余数
        let r = n1 % n2
        // 当到 13 = 4*3 + 1 即4 % 1 = 0时 返回
        // 返回值为：1 | -4 即：x=1 y=-4
        if (n2 % r === 0) {
            // 转化为：1 = 13 + 4*(-3)
            // 所以返回：x=1 y=q*(-1)=-3
            return [1, q * -1]
        } else {
            let ret = this.gcdEx(n2, r)
            // x和y为上一步返回的值
            let x = ret[0]
            let y = ret[1]
            // x1和y1为当前步骤的值
            let x1 = 1
            let y1 = -q
            // console.log('----', x, y, x1, y1)
            // x2和y2为当前步骤计算得到的值
            // 1 = 13 + 4*(-3)
            // 4 = 17 + 13*(-1)
            // 代入得：1 = 13 + (17 + 13*(-1)) * (-3)
            // 计算得：1 = 17*(-3) + 13*4 ==> x=-3 | y=4
            let x2 = y * x1
            let y2 = y * y1 + x
            ret = [x2, y2]
            return ret
        }
    }
}
export default Gcd
```



（4）裴蜀定理的求解-扩展欧几里得算法

```tsx
/**
 * 最大公约数
 */
class Gcd {
    /**
     * 计算2个数的最大公约数
     * @param n1 数1
     * @param n2 数2
     */
    public static gcd(n1: number, n2: number): number {
        let s = Math.floor(n1 / n2)
        let y = n1 % n2
        // console.log(n1 + ' = ' + n2 + '*' + s + ' + ' + y)
        if (y === 0) {
            return n2
        } else {
            return this.gcd(n2, y)
        }
    }
    /**
     * 扩展欧几里德算法 - 求方程的解 （详细注释版）
     * 我们要求：47x + 30y = 1的解，下面为辗转相除法的步骤：
     * 47 = 30*1 + 17
     * 30 = 17*1 + 13
     * 17 = 13*1 + 4
     * 13 = 4*3 + 1
     *
     *
     * @param num1 数1
     * @param num2 数2
     */
    public static gcdEx(n1: number, n2: number): Array<number> {
        // 两数相除的商
        let q = Math.floor(n1 / n2)
        // 两数相除的余数
        let r = n1 % n2
        // 当到 13 = 4*3 + 1 即4 % 1 = 0时 返回
        // 返回值为：1 | -4 即：x=1 y=-4
        if (n2 % r === 0) {
            // 转化为：1 = 13 + 4*(-3)
            // 所以返回：x=1 y=q*(-1)=-3
            return [1, q * -1]
        } else {
            let ret = this.gcdEx(n2, r)
            // x和y为上一步返回的值
            let x = ret[0]
            let y = ret[1]
            // x1和y1为当前步骤的值
            let x1 = 1
            let y1 = -q
            // console.log('----', x, y, x1, y1)
            // x2和y2为当前步骤计算得到的值
            // 1 = 13 + 4*(-3)
            // 4 = 17 + 13*(-1)
            // 代入得：1 = 13 + (17 + 13*(-1)) * (-3)
            // 计算得：1 = 17*(-3) + 13*4 ==> x=-3 | y=4
            let x2 = y * x1
            let y2 = y * y1 + x
            ret = [x2, y2]
            return ret
        }
    }
}
export default Gcd
```





### DH算法

#### 离散对数

DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是**离散对数**。

对数运算：$i = log_{a}b$

离散对数是在对数运算的基础上加了「模运算」，也就说取余数，对应编程语言的操作符是「%」，也可以用 mod 表示。离散对数的概念如下图：

<center><img src="assets/image-20220911172944423.png" width="80%"></center>

上图的，底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。

特别是**当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的**，这就是 DH 算法的数学基础。




#### DH算法

现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。

然后小红和小明各自生成一个随机整数作为私钥，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。

现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出公钥：

- 小红的公钥记作 A，$A = G ^ a \ ( mod \ P )$；
- 小明的公钥记作 B，$B = G ^ b \ ( mod \ P )$；

A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。

双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。

然后小红执行运算：$ B ^ a ( mod P )$，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： $A ^ b ( mod P )$，得到的结果也是 K。

<center><img src="assets/5b15f409f83ac83a7a713dc1d5637d48.png" ></center>

这个 K 就是小红和小明之间用的对称加密密钥，可以作为会话密钥使用。

可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。

前面也多次强调， 根据离散对数的原理，**如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的**。


#### DHE 算法
根据私钥生成的方式，DH 算法分为两种实现：

- **static DH** 算法，这个是已经被废弃了；
- **DHE** 算法，现在常用的；

static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。

于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 static DH 算法不具备前向安全性。

既然固定一方的私钥有被破解的风险，那么干脆就**让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的**，这个方式也就是 DHE 算法，E 全称是 **ephemeral**（临时性的）。

所以，**即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」**。



#### ECDHE 算法
DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— ECDHE 算法。

ECDHE 算法是在 DHE 算法的基础上利用了 **ECC 椭圆曲线特性**，可以用更少的计算量计算出公钥，以及最终的会话密钥。

小红和小明使用 ECDHE 密钥交换算法的过程：

- 双方事先确定好**使用哪种椭圆曲线，和曲线上的基点 G**，这两个参数都是公开的；
- 双方各自随机生成一个随机数作为私钥d，并与基点 G相乘得到公钥Q（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；
- 双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此双方的 x 坐标是一样的，所以它是**共享密钥**，也就是会话密钥(其实在TLS中**最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的**)。

这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。





### ECC算法

#### 椭圆曲线

ECC是椭圆曲线加密算法，Wolfram MathWorld（线上数学百科全书，[http://mathworld.wolfram.com](https://link.segmentfault.com/?enc=G%2FsNVFAa%2FFQgCiXYz%2BtCkQ%3D%3D.B8DXpJq3UzyC9eGxOHgs9NP5pmj7KPSY8dHAt%2Bn5iH8%3D)） 给出了非常精准的定义：一条椭圆曲线就是一组被 $y^2 = x^3 + ax + b $定义的且满足 $4a^3 + 27b^2 ≠ 0$ 的点集。$4a^3 + 27b^2 ≠ 0$ 这个限定条件是为了保证曲线不包含奇点（在数学中是指曲线上任意一点都存在切线）。椭圆曲线示例图：

<center><img src="assets/bVbsBEV.png" ></center>

不同的椭圆曲线对应不同的形状（b=1，a从2到-3)

<center><img src="assets/bVbsBFL.png" ></center>

左（带锐点）：$y^2 = x^3$
右（曲线自交）：$y^2 = x^3 -3x + 2$
**都不是有效的椭圆曲线**



#### 椭圆曲线的二元运算

（1）加法

<center><img src="assets/image-20220911195805710.png" ></center>



（2）乘法

以2A为例：

<center><img src="assets/image-20220911195932341.png" ></center>

3A：

<center><img src="assets/image-20220911200124004.png" ></center>



> 因此，在ECC算法中，Q(公钥)=kP很好算，但是根据Q和P求出k(私钥)很难。



#### 关于阿贝尔群(abelian group)

阿贝尔群的概念是抽象代数的基本概念之一，是一种代数结构，由一个集合以及一个二元运算所组成。如果一个集合或者运算是群的话，就必须满足以下条件（+ 表示二元运算）：

1. 封闭性（closure），如果a和b被包含于群，那么a+b也一定是群的元素；
2. 结合律(associativity)；
3. 存在一个单位元（identity element）0，0与任意元素运算不改变其值的元素，即 a+0 = 0+a = a；
4. 每个元素都存在一个逆元(inverse)；
5. 交换律(commutativity)，即 a+b = b+a；



#### 椭圆曲线中的阿贝尔群

我们可以在椭圆曲线上定义一个群：

1. 群中的元素就是椭圆曲线上的点；
2. 单位元就是无穷处的点0；
3. 相反数P，是关于X轴对称的另一边的点；
4. 二元运算规则定义如下：取一条直线上的三点（这条直线和椭圆曲线相交的三点），P, Q, R（皆非零），他们的总和等于0，P+Q+R=0。

<center><img src="assets/bVbsBIP.png" ></center>

如果P, Q, R在一条直线上的话，他们满足:
$$
P+(Q+R)=Q+(P+R)=R+(P+Q)=⋯=0。
$$
当P，Q点为同一点时,P=Q，满足：

<center><img src="assets/bVbsBI0.png" ></center>

这样，我们可以直观的证明：+运算符是符合交换律和结合律的，这是一个阿贝尔群。

因为阿贝尔群满足交换律和结合律，所以点P和点-R的二元运算结果必会在曲线上，即P+P+P的结果必会在曲线上的另一点Q，

以此类推，可以得出得出：
$$
Q=kP(k个相同的点P进行二元运算（数乘）,记做kP)
$$


#### **椭圆曲线加密算法原理**

描述一条Fp上的椭圆曲线，常用到六个参量：T=(p,a,b,n,x,y)。（p 、a 、b） 用来确定一条椭圆曲线，p为素数域内点的个数，a和b是其内的两个大数；

x,y为G基点的坐标，也是两个大数；n为点G基点的阶；

以上六个量就可以描述一条椭圆曲线，有时候我们还会用到h(椭圆曲线上所有点的个数p与n相除的整数部分)。

现在我们描述一个利用椭圆曲线进行加密通信的过程：

1. 选定一条椭圆曲线 Ep(a,b) 并取椭圆曲线上一点，作为基点P（比如(0,1)）；

2. 选择一个大数k作为私钥，并生成公钥 Q=kP；

3. 将 Ep(a,b) 和点Q、P传给用户；

4. 用户接到信息后 ，选择一个随机数r，将消息M生成密文C，C是一个点对，C=(rP，M+rQ)，并发送；

5. 私钥解密（M + rQ - k(rP) ，解密结果就是点M），公式如下：
   $$
   M + rQ - k(rP) = M + r(kP) - k(rP) = M
   $$

7. 对点M进行解码就可以得到明文

   假设在加密过程中，有一个第三者H，H只能知道椭圆曲线 Ep(a,b)、公钥Q、基点P、密文点C，而通过公钥Q、基点P求私钥k或者通过密文点C、基点P求随机数r都是非常困难的，因此得以保证数据传输的安全。

